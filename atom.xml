<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fujie&#39;s Blog</title>
  
  <subtitle>学习&amp;生活</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://sioce.me/"/>
  <updated>2020-09-21T03:01:45.630Z</updated>
  <id>http://sioce.me/</id>
  
  <author>
    <name>Fujie</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>target</title>
    <link href="http://sioce.me/2020/09/21/target/"/>
    <id>http://sioce.me/2020/09/21/target/</id>
    <published>2020-09-21T02:54:28.000Z</published>
    <updated>2020-09-21T03:01:45.630Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定个小目标"><a href="#定个小目标" class="headerlink" title="定个小目标"></a>定个小目标</h2><a id="more"></a><p>一年之约</p><ul><li><input disabled="" type="checkbox"> 攒两万块钱</li><li><input disabled="" type="checkbox"> 发一篇文章</li><li><input disabled="" type="checkbox"> 明年国庆青海自驾</li><li><input disabled="" type="checkbox"> 学习摄影</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;定个小目标&quot;&gt;&lt;a href=&quot;#定个小目标&quot; class=&quot;headerlink&quot; title=&quot;定个小目标&quot;&gt;&lt;/a&gt;定个小目标&lt;/h2&gt;
    
    </summary>
    
    
      <category term="小记" scheme="http://sioce.me/categories/%E5%B0%8F%E8%AE%B0/"/>
    
    
      <category term="心情" scheme="http://sioce.me/tags/%E5%BF%83%E6%83%85/"/>
    
  </entry>
  
  <entry>
    <title>Python高级语法</title>
    <link href="http://sioce.me/2020/08/28/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/"/>
    <id>http://sioce.me/2020/08/28/Python%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/</id>
    <published>2020-08-28T06:29:12.000Z</published>
    <updated>2020-08-28T06:38:30.880Z</updated>
    
    <content type="html"><![CDATA[<h2 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h2><ul><li>可变数据类型<ol><li>列表-list</li><li>字典-dict</li></ol></li><li>不可变数据类型<ol><li>整形</li><li>浮点型</li><li>布尔型</li><li>字符串型</li><li>元组</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;变量赋值&quot;&gt;&lt;a href=&quot;#变量赋值&quot; class=&quot;headerlink&quot; title=&quot;变量赋值&quot;&gt;&lt;/a&gt;变量赋值&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;可变数据类型&lt;ol&gt;
&lt;li&gt;列表-list&lt;/li&gt;
&lt;li&gt;字典-dict&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
      
    
    </summary>
    
    
      <category term="技术笔记" scheme="http://sioce.me/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python" scheme="http://sioce.me/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>new&amp;delete关键字</title>
    <link href="http://sioce.me/2020/08/27/new-delete%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://sioce.me/2020/08/27/new-delete%E5%85%B3%E9%94%AE%E5%AD%97/</id>
    <published>2020-08-27T05:55:40.000Z</published>
    <updated>2020-08-28T01:37:47.661Z</updated>
    
    <content type="html"><![CDATA[<h2 id="重载为全局函数"><a href="#重载为全局函数" class="headerlink" title="重载为全局函数"></a>重载为全局函数</h2><ul><li>小心操作，影响范围大；</li><li><strong>::operator new(size_t size)</strong>、<strong>::operator[] new(size_t size)</strong>，必须传入size_t类型参数；</li><li><strong>::operator delete(void* ptr)</strong>、<strong>::operator[] delete(void* ptr)</strong>，必须传入指针类型参数；</li></ul><h2 id="重载为成员函数"><a href="#重载为成员函数" class="headerlink" title="重载为成员函数"></a>重载为成员函数</h2><ul><li>如果类重载了new、delete，仍然可以强制使用全局的new和delete，语法为：<code>Foo* ptr = ::new Foo</code>;</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;重载为全局函数&quot;&gt;&lt;a href=&quot;#重载为全局函数&quot; class=&quot;headerlink&quot; title=&quot;重载为全局函数&quot;&gt;&lt;/a&gt;重载为全局函数&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;小心操作，影响范围大；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;::operator new(
      
    
    </summary>
    
    
      <category term="技术笔记" scheme="http://sioce.me/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://sioce.me/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>const关键字</title>
    <link href="http://sioce.me/2020/08/27/const%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://sioce.me/2020/08/27/const%E5%85%B3%E9%94%AE%E5%AD%97/</id>
    <published>2020-08-27T05:55:26.000Z</published>
    <updated>2020-08-27T06:27:23.549Z</updated>
    
    <content type="html"><![CDATA[<pre><code class="C++">//例程1class A {    int real() const {return re;}};</code></pre><ul><li>例程1展示了<code>const</code>的一种用法，表示成员函数不打算修改类的成员变量，一般只能再成员函数中这样使用，而不再全局函数中使用；</li></ul><table><thead><tr><th align="center">~</th><th align="center">const修饰对象</th><th align="center">non-const对象</th></tr></thead><tbody><tr><td align="center">cosnt mem-func</td><td align="center">可调用</td><td align="center">可调用</td></tr><tr><td align="center">non-const mem-func</td><td align="center">不可调用</td><td align="center">可调用</td></tr></tbody></table><ul><li>non-const成员函数可以调用const成员函数，反之则不行；</li><li>当成员函数的const版本和non-const版本同时存在时，const对象只会调用const成员函数，non-const对象只会调用non-const成员函数。</li><li>cosnt修饰返回值，要求返回值为引用类型，表示函数不会修改该返回值。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code class=&quot;C++&quot;&gt;//例程1
class A {
    int real() const {return re;}
};&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;例程1展示了&lt;code&gt;const&lt;/code&gt;的一种用法，表示成员函数不打算修改类
      
    
    </summary>
    
    
      <category term="技术笔记" scheme="http://sioce.me/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://sioce.me/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>虚指针&amp;虚函数表</title>
    <link href="http://sioce.me/2020/08/27/%E8%99%9A%E6%8C%87%E9%92%88-%E8%99%9A%E8%A1%A8/"/>
    <id>http://sioce.me/2020/08/27/%E8%99%9A%E6%8C%87%E9%92%88-%E8%99%9A%E8%A1%A8/</id>
    <published>2020-08-27T02:44:21.000Z</published>
    <updated>2020-08-27T05:55:11.569Z</updated>
    
    <content type="html"><![CDATA[<h2 id="虚指针-amp-虚函数"><a href="#虚指针-amp-虚函数" class="headerlink" title="虚指针&amp;虚函数"></a>虚指针&amp;虚函数</h2><pre><code class="C++">// 例程1class A {public:    virtual void vfunc1();    virtual void vfunc2();    void func1();    void func2();private:    int m_data1, m_data2;}class B : public A {public:    virtual void vfunc1();    void func2();private:    int m_data3;}class C : public B{public:    virtual void vfunc1();    void func2();private:    int m_data1, m_data4;}</code></pre><center><img src="https://przmzw.bl.files.1drv.com/y4mghqmiLIR05qC1QhB-gFL_XFr4BgCZXlpaO2JSyJ0c-tVRARfOoqPjZNyH-TV_Bzj0KA-jl1Yn30VzfxSl8qQkI-O-RMY0anR5w2xqM2g6KT2Jy7J4ZKQBDc_hx2BUVDVQWhGTx9OyTozsFJj2sp-DVftpKcNP7H84erWYNNKah29QrnyOY2CTTK8A5PfKpAXdXdImwLDoNIIPz1uUjQx9g?width=750&height=451&cropmode=none" width="60%" /><br>图1  例程1内存布局</center><ul><li>如上图所示，通过指针p访问虚函数的方法为：<code>(*(p-&gt;vptr)[n])(p) or (* p-&gt;vptr[n])(p)</code></li></ul><h2 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h2><ul><li>动态绑定的三个条件：指针、向上转型、虚函数；</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;虚指针-amp-虚函数&quot;&gt;&lt;a href=&quot;#虚指针-amp-虚函数&quot; class=&quot;headerlink&quot; title=&quot;虚指针&amp;amp;虚函数&quot;&gt;&lt;/a&gt;虚指针&amp;amp;虚函数&lt;/h2&gt;&lt;pre&gt;&lt;code class=&quot;C++&quot;&gt;// 例程1
class A
      
    
    </summary>
    
    
      <category term="技术笔记" scheme="http://sioce.me/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://sioce.me/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>引用</title>
    <link href="http://sioce.me/2020/08/26/%E5%BC%95%E7%94%A8/"/>
    <id>http://sioce.me/2020/08/26/%E5%BC%95%E7%94%A8/</id>
    <published>2020-08-26T08:02:39.000Z</published>
    <updated>2020-08-27T02:42:18.154Z</updated>
    
    <content type="html"><![CDATA[<ul><li>引用的实质就是指针；</li><li>定义引用必须设置初值，且不可再作为初值外的其他值的别名；</li></ul><center><img src="https://phzmzw.bl.files.1drv.com/y4mH8YInh5P7KL5DKsoJkQc3mQlSzvTT1lJjFHZ2hIoS4CW5GGO7iVerPtrkL1vd1hKiOKILZuTnyb9JoEcrYPq3MsHNf0FRBllka2atiEKctTW8tOieVqKHNZesubyZ1mVd4rNkzt9PbANcEiYrnu21Cpwf_eSxJJmeW5lF1ajeNR3ZjJ3uJdVdbGTB4HHNHuweQT11sC7zSt9QbCz6gXYcA?width=726&height=518&cropmode=none" width="60%" /><br>图1  例程1内存布局</center><ul><li><strong>const</strong>关键字是签名的一部分；</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;引用的实质就是指针；&lt;/li&gt;
&lt;li&gt;定义引用必须设置初值，且不可再作为初值外的其他值的别名；&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;
&lt;img src=&quot;https://phzmzw.bl.files.1drv.com/y4mH8YInh5P7KL5DKso
      
    
    </summary>
    
    
      <category term="技术笔记" scheme="http://sioce.me/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://sioce.me/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>STL</title>
    <link href="http://sioce.me/2020/08/26/STL/"/>
    <id>http://sioce.me/2020/08/26/STL/</id>
    <published>2020-08-26T07:14:04.000Z</published>
    <updated>2020-08-28T06:18:57.917Z</updated>
    
    <content type="html"><![CDATA[<center><img src="https://pbzmzw.bl.files.1drv.com/y4mGv90-Tg9QH5PM9B8Kd_pkQtLePsgZBUV1Y4PcTBcUd3-CH0ic7jqAYD0KFVkudfyynB0pcnuPxvmiWlrN6s-3XZdwkA_vaDsnP-ddtR3CEsXB4P7gjjf88fI910vXA17Ijj86ES9lTvN9M6vLNZJ21Qhw5BIJuj0YHMg-r4aRvpprZ6SfIfMHSy8-m67j7198pflY4qVnShz4AZRHNEDDQ?width=353&height=298&cropmode=none" width="60%" /><br>图1  STL</center><ul><li>标准库包含四部分内容：<ol><li>容器；</li><li>分配器；</li><li>算法；</li><li>迭代器；</li><li>适配器；</li><li>仿函数；</li></ol></li><li>模板编程将算法和数据进行一定程度的分离；</li><li>标准库使用的是前闭后开区间，如<code>begin()</code>指向容器第一个元素，<code>end()</code>指向容器最后一个元素的下一个；</li></ul><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="结构分类"><a href="#结构分类" class="headerlink" title="结构分类"></a>结构分类</h3><ul><li>序列容器：<ol><li>array，元素数量固定；</li><li>vector，后端增长；</li><li>deque，两端增长，分段连续；</li><li>list，双向<em>环状</em>链表；</li><li>forward-list，单向链表</li></ol></li><li>关联容器——<strong>key-val</strong>：<ol><li>set/multiset，红黑树。set元素不能重复，后者可以；</li><li>map/multimap，红黑树。map元素不能重复，后者可以；</li></ol></li><li>不定序容器：<ol><li>Unordered set/multiset，哈希表；</li><li>Unordered map/multimap，哈希表；</li></ol></li><li>stack&amp;queue的底层都是deque，且不支持迭代器；</li></ul><h2 id="分配器"><a href="#分配器" class="headerlink" title="分配器"></a>分配器</h2><pre><code class="C++">#include &lt;ext/array_allocator.h&gt;#include &lt;ext/mt_allocator.h&gt;  //multi-thread#include &lt;ext/debug_allocator.h&gt;#include &lt;ext/pool_allocator.h&gt;#include &lt;ext/bitmap_allocator.h&gt;#include &lt;ext/malloc_allocator.h&gt;#include &lt;ext/new_allocator.h&gt;</code></pre><ul><li>GNU中的分配器如例程1所示，GNU中的分配器一般搭配容器使用，也可以单独使用，但没有必要；</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;
&lt;img src=&quot;https://pbzmzw.bl.files.1drv.com/y4mGv90-Tg9QH5PM9B8Kd_pkQtLePsgZBUV1Y4PcTBcUd3-CH0ic7jqAYD0KFVkudfyynB0pcnuPxvmiWlrN6s-3
      
    
    </summary>
    
    
      <category term="技术笔记" scheme="http://sioce.me/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://sioce.me/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>模板</title>
    <link href="http://sioce.me/2020/08/24/%E6%A8%A1%E6%9D%BF/"/>
    <id>http://sioce.me/2020/08/24/%E6%A8%A1%E6%9D%BF/</id>
    <published>2020-08-24T14:13:07.000Z</published>
    <updated>2020-08-26T07:58:28.523Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h2><ul><li>实例化时需要使用尖括号指定模板类型；</li></ul><h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><ul><li>使用的时候不必指明类型，编译器自动进行实参推导；</li></ul><h2 id="成员模板"><a href="#成员模板" class="headerlink" title="成员模板"></a>成员模板</h2><center><img src="https://phyb3a.bl.files.1drv.com/y4m1qj-Ep49TLSHHa-L0qdX_G9eU8ZydrnJ9koPDmRQUnOD-fQUW3xUzThJaVNipoFIVFaPHCncgj3fuK9CnP2x9TqbBq1Qz09Aclh3pMLR-iTCT2FvEpmjoKZ7IhqSMCQU3pkHsZQuu3fD2UyDo3xhuZ5Z5_CRvYrghX9OYrVKb_FXdM1faaVSMKqoapHrRUlBQpQJbllUxoY9IG_f1PqpVw?width=603&height=481&cropmode=none" width="60%" /><br>图1  成员模板代码</center><pre><code class="C++">// 例程1class Base1 {};class Derived1: public Base1 {};class Base2 {};class Derived2: public Base2 {};pair&lt;Derived1, Derived2&gt; p1; //p1pair&lt;Base1, Base2&gt; p2(p1);   //p2</code></pre><ul><li>图1中的黄色部分即为成员模板，例程1即为一种成员模板的使用方式，注意U1、U2和T1、T2的关联关系。</li><li>例程2给出了标准库中成员模板的一个例子，通过使用成员模板模拟类型为父类的指针，指向子类对象的用法；</li></ul><pre><code class="C++">// 例程2template&lt;typename _Tp&gt;class shared_ptr:public __shared_ptr&lt;_Tp&gt;{...    template&lt;typename _Tp1&gt;    explicit shared_ptr(_Tp1* __p)     : __shared_ptr&lt;_Tp&gt;(__p) {}...};Base* ptr = new Derived1; //up-castshared_ptr&lt;Base1&gt; sptr(new Derived1); //模拟up-cast</code></pre><h2 id="模板特化-specialization"><a href="#模板特化-specialization" class="headerlink" title="模板特化-specialization"></a>模板特化-specialization</h2><pre><code class="C++">// 例程3template&lt;class Key&gt; //p1struct hash {};     //p2template&lt;&gt;     //p3struct hash&lt;char&gt; {    size_t operator() (char x) const {return x};};</code></pre><center><img src="https://qbyb3a.bl.files.1drv.com/y4mQiczdfJ--l7GhgOfVgCZsyvUHQd8tzSzoat3IH8TOq76lv-ReKbO7CtP5GjCrHQ8Sv0gS2-lfbqHkxqURmkN6eR2H2UrbwgsltYl2Y3EoSRhKyu9r9yW35sxIWnNjTp-A_aG47Y-T9BnFivhKV6GtePId-eqOU7OCg2Kx82BvnS1Aq-A7LXtbenqIOZEBXC6ZKxFPUIDkyp_YXvFYgRWqw?width=603&height=314&cropmode=none" width="60%" /><br>图2  specialization-个数</center><center><img src="https://pxyb3a.bl.files.1drv.com/y4mbPHvGaMZGWYQX9ULqtq290I6t0E3PFyo1pN6_gTZkczGc8YRjtTmn0kqzicOaxtQTu7Cqi4dcGYHTFJwHXGsPZgZCb_8yBQW71DzJ7KvDbREErr3t-RCfIt5RRhZIZZceNoXErmoJYOoWJy_x_ghn8mP9VT_uGySWhiNf889IgiAwA24X3mi542WUq9Eugccbybc4JiiJBE-KKCoTNlOsw?width=326&height=320&cropmode=none" width="60%" /><br>图3  specialization-范围</center><ul><li>例程3展示了模板特化的例子，当传入的类型为<code>char</code>时，编译器会首先调用特化的代码，即p3后的代码，其他类型方会执行p1、p2行；</li><li>模板的特化分为两类：<ol><li><strong>全特化</strong>；</li><li><strong>偏特化</strong>：也叫做局部特化，<em>偏</em>可以从两个方面理解：个数上和范围上；<ul><li>个数上，如图二所示，将<code>typename T</code>绑定为布尔值。</li><li>范围上，如图三所示，当使用指针时，就会使用图3下面代码，否则使用上面代码；</li></ul></li></ol></li></ul><h2 id="模板模板参数"><a href="#模板模板参数" class="headerlink" title="模板模板参数"></a>模板模板参数</h2><center><img src="https://8hyb3a.bl.files.1drv.com/y4mvbgVjrqAMI7SRs7ekfeDXO-uM1NxhbWHy7dfiRGLJWY_qFQubRA7Xs_7aF65VzvlavNKvwNMsGpbwQOeyJCF4o3hrat3S7-mzJ9dpwyj6bTZd-xRHClOni6D_RfHvjQ3dgCR95_bOZxLtEJdfgGLu6oYwdEQzC2O9BSqTdpwkAOy3nr15v0vmO4IZrtUrrEJ9tOdtSbwG_h-vMoQY7b_2A?width=634&height=498&cropmode=none" width="60%" /><br>图4 模板模板参数</center><ul><li>上图黄色部分即为模板模板参数的一个示例；</li><li><code>template&lt;class T&gt;</code>和<code>template&lt;typename T&gt;</code>只有在这种情况下，尖括号内使用template和class是一样的效果，其他地方不适用这条规则；<ol><li>图4中深色部分的第一行代码的用法是错误的，虽然它符合我们使用的习惯，但容器是存在第二、甚至第三模板参数的，这个时候需要我们手动指定这些参数。如图4中间代码所示。</li></ol></li></ul><h2 id="数量不定模板参数-C-11"><a href="#数量不定模板参数-C-11" class="headerlink" title="数量不定模板参数(C++11)"></a>数量不定模板参数(C++11)</h2><pre><code class="C++">//例程4void print() {}template&lt;typename T, typename... Types&gt;void print(const T&amp; firstArg, const type&amp;... args) { //p1  cout &lt;&lt; firstArg &lt;&lt; endl;  sizeof...(args); //计算args中的参数量  print(args...);}print(7.5, &quot;hello&quot;, bitset&lt;16&gt;(377), 42); //p2</code></pre><ul><li>执行例程4中的p2行，将循环调用p1行定义的函数，当42打印完成后，传入参数的数量为0，此时调用p1行的代码将报错，故而另外定义了一个没有参数的<code>print</code>函数。</li><li><code>...</code>被称为包<strong>pack</strong>：<ol><li>将他用做模板参数，则称为模板参数包；</li><li>用作函数参数类型，就称为函数参数类型包；</li><li>用作函数参数，就称为函数参数包；</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;类模板&quot;&gt;&lt;a href=&quot;#类模板&quot; class=&quot;headerlink&quot; title=&quot;类模板&quot;&gt;&lt;/a&gt;类模板&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;实例化时需要使用尖括号指定模板类型；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;函数模板&quot;&gt;&lt;a href=&quot;#函数模板&quot; 
      
    
    </summary>
    
    
      <category term="技术笔记" scheme="http://sioce.me/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://sioce.me/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>关于智能指针</title>
    <link href="http://sioce.me/2020/08/24/%E5%85%B3%E4%BA%8E%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    <id>http://sioce.me/2020/08/24/%E5%85%B3%E4%BA%8E%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</id>
    <published>2020-08-24T12:55:16.000Z</published>
    <updated>2020-08-24T14:12:36.277Z</updated>
    
    <content type="html"><![CDATA[<h2 id="pointer-like-classes，智能指针"><a href="#pointer-like-classes，智能指针" class="headerlink" title="pointer-like classes，智能指针"></a>pointer-like classes，智能指针</h2><pre><code class="C++">//例程1template&lt;class T&gt;class shared_ptr{public:    T&amp; operator() const {return *px;}    T* operator-&gt;() const {return px;}    shared_ptr(T* p) : px(p) {}private:    T* px;    long* pn;}struct Foo{    ····    void method(void) {···}}shared_ptr&lt;Foo&gt; sp(new Foo); //p1sp-&gt;method();                //p2</code></pre><ul><li>类对象的使用和指针的使用相似，但做的工作更多；</li><li>注意例程1中p1和p2行，<code>-&gt;</code>符号作用一次后还可以继续起作用；</li></ul><h2 id="pointer-like-classes，迭代器"><a href="#pointer-like-classes，迭代器" class="headerlink" title="pointer-like classes，迭代器"></a>pointer-like classes，迭代器</h2><center><img src="https://pxacua.bl.files.1drv.com/y4mLqj5JZfSCiPdQZOcjTCYUpqk0omGglFbWGDsuTKas_JhIxTURGc-9Jo5GrH6y4dzGd9UGj-DhgQL3SEEf5q66FoqLdRigYI3-zEsc0fLelmKmIbsb4FDSrFFfRh80BIMzi6bzHVhrVzg1Ej5MK1e_JQlI3S4cF0sVUBU-tOytl7_iOYSut3XmsY5gQvg4aOdKRj8PCjMwHG4_W5nznZBkQ?width=967&height=489&cropmode=none" width="60%" /><br>图1  迭代器代码</center><center><img src="https://8hacua.bl.files.1drv.com/y4mj1MmsqFapoWaSOTWj6ACymrt6fbs6lxRlu6FHjVbcAEQguKNNE8pZErt7GTpeWqmXzGaxj6ic8x26JQJApsDL_3bZgN80bOtno0IbzXWSpU_RlHAVF9XLTm2aPuDrFK_O-7-YIcTj5F1_VUBbn5Fg4bPKAy3dODClRtMGKjgbFmBn-iF-jOMcbRX5YxqV_jPXT0stX87Yfol2QgJCTvY4A?width=828&height=273&cropmode=none" width="60%" /><br>图2  迭代器示意图</center><ul><li>迭代器不仅需要重载<code>*、-&gt;</code>操作符</li><li>好需要重载自增、自减操作符；</li><li>对迭代器解参考，就相当于取对应的<code>data</code>;</li></ul><h2 id="pointer-like-function，仿函数"><a href="#pointer-like-function，仿函数" class="headerlink" title="pointer-like function，仿函数"></a>pointer-like function，仿函数</h2><center><img src="https://8racua.bl.files.1drv.com/y4mwxdg9rNzup9WC8-8omPXXKsQjnjzXm_fOUcNBJ-RBW4tFnOw1l-APdsckqn7o2S6rwpnyu6V0trflWWNEtvhPI2RSE4RKA4YxY3F1Mc_w63Esok1I1FIdJjb6n90tAsRjt82JiDDjLMexdoHxj3TtPap13rpKuVSr5tFuzBdtHDFoGpJBR4ovFBcN2gEiN8yEEDxfOG_HdLwr6rxUoMmiA?width=977&height=491&cropmode=none" width="60%" /><br>图2  仿函数代码</center><pre><code class="C++">//例程2select1st&lt;pair&gt;()();</code></pre><ul><li><code>()</code>函数调用操作符，接受小括号操作符的东西叫做函数或者仿函数；</li><li>例程2中代码使用两个小括号，第一个是构造对象，第二个是调用<code>()</code>操作符重载函数；</li><li>标准库中的仿函数都会继承奇特的基类，图2并没有写出来（灰色部分）；</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;pointer-like-classes，智能指针&quot;&gt;&lt;a href=&quot;#pointer-like-classes，智能指针&quot; class=&quot;headerlink&quot; title=&quot;pointer-like classes，智能指针&quot;&gt;&lt;/a&gt;pointer-lik
      
    
    </summary>
    
    
      <category term="技术笔记" scheme="http://sioce.me/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://sioce.me/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>转换函数</title>
    <link href="http://sioce.me/2020/08/24/%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0/"/>
    <id>http://sioce.me/2020/08/24/%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0/</id>
    <published>2020-08-24T08:44:47.000Z</published>
    <updated>2020-08-24T14:12:39.218Z</updated>
    
    <content type="html"><![CDATA[<ul><li>将一种类型转换为其他类型，或者将其他类型转化为本类型；</li></ul><pre><code class="C++">// 例程1class Fraction{public:    Fraction(int num, int den=1) //这是一种特殊的构造函数，non-explicit-one-argument构造函数        : M_numerator(num), m_denominator(den) {}    operator double() const { // 无需指定参数与返回类型，编译器自动设置返回类型为double        return (double) (m_numerator / m_denominator);    }    Fraction operator+(const Fraction&amp; f) {        return Fraction(....);    }private:    int m_numerator;    int m_denominator;}Fraction f(3, 5); //p1double d = 4 + f; //p2Fraction f(3, 5); //p3Fraction d2 = f + 4; //p4</code></pre><h2 id="转出去"><a href="#转出去" class="headerlink" title="转出去"></a>转出去</h2><ul><li>假设注释掉例程1中的<code>Fraction operator+</code>函数，执行p1、p2行将调用<code>operator double()</code>将f转为0.6；</li></ul><h2 id="转进来"><a href="#转进来" class="headerlink" title="转进来"></a>转进来</h2><h3 id="non-explicit-one-argument构造函数"><a href="#non-explicit-one-argument构造函数" class="headerlink" title="non-explicit-one-argument构造函数"></a>non-explicit-one-argument构造函数</h3><ul><li>假设注释掉例程1中的<code>operator double()</code>函数，执行p3、p4行，<code>+</code>号作用于对象f，编译器查找类Fraction是否重载操作符<code>+</code>，存在则调用，但它的参数为Fraction，这时就会调用non-explicit-one-argument构造函数将4转化为Fraction对象进行计算；</li><li>如果运行例程1的完整代码，将产生错误。</li><li>使用<code>explict</code>修饰Fraction的构造函数，编译器就不会将该函数作为转换函数，执行p3、p4行将报错。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;将一种类型转换为其他类型，或者将其他类型转化为本类型；&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;C++&quot;&gt;// 例程1
class Fraction
{
public:
    Fraction(int num, int den=1) //这是
      
    
    </summary>
    
    
      <category term="技术笔记" scheme="http://sioce.me/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://sioce.me/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>django简介</title>
    <link href="http://sioce.me/2020/08/22/django%E7%AE%80%E4%BB%8B/"/>
    <id>http://sioce.me/2020/08/22/django%E7%AE%80%E4%BB%8B/</id>
    <published>2020-08-22T13:45:42.000Z</published>
    <updated>2020-08-26T15:00:47.118Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Django基础"><a href="#Django基础" class="headerlink" title="Django基础"></a>Django基础</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul><li>python语言web框，下列框架都遵循<strong>MVC</strong>设计模式，因此本文主要介绍Django。<ol><li>web.py;</li><li><strong>Django</strong>(MTV框架);</li><li>Flask;</li><li>Tornado;</li><li>AIOHTTP;</li><li>FastAPI;</li></ol></li></ul><center><img src="https://pracua.bl.files.1drv.com/y4mtD0YhXfafTW6WrJGW1W06QTu6XCd6sjbnM-kQdxzHxeB3ssW-GAAC5I1omEAx2KpeUcgBfBzC5Uw3S-ZD_68W5AiXvqXM0uCOp2X8ZL0_hId-wuu2zHa_0KlrsO3RMxiYDOHbTxxlO2hv9qQb2u2BvyK8FQ6ecVXibXA7FCZ7qLoKdMAv7nyjaKHuSVdZIozlxe3HuQtdT4dUTPU9fn26Q?width=660&height=474&cropmode=none" width="40%" high="40%"/><br>图1  Django MTV架构</center><ul><li><p>Django采用MTV框架（如图1），另外还遵循<strong>代码复用DRY</strong>原则；</p></li><li><p>Django的组件：</p><ol><li><strong>ORM-对象甚映射</strong>，映射类来构建数据模型；</li><li>URL支持正则表达式；</li><li>模板可以继承；</li><li>内置用户认证，提供用户认证和权限功能；</li><li>admin管理系统；</li><li>内置表单模型、cache缓存系统、国际化系统等；</li></ol></li><li><p>Django安装(2020-9)</p><ol><li>目前建议使用<em>Django2.2.13</em>，最新版为3.0.</li><li>如果维护已存在Django代码，建议使用已有代码采用的Django版本。如果需要升级请进行兼容性测试；</li><li>安装指令：<code>pip install --upgrade django==2.2.13</code></li></ol></li><li><p>使用Django：</p><ol><li>创建Django项目：<code>django-admin startprojet project_name</code></li><li>创建Django应用程序：<code>python manage.py startapp index</code></li><li>启动应用程序：<code>python manage.py runserver ip:port</code></li><li>退出程序：<code>CONTROL+C</code></li></ol></li></ul><h3 id="Django目录结构"><a href="#Django目录结构" class="headerlink" title="Django目录结构"></a>Django目录结构</h3><center><img src="https://pbacua.bl.files.1drv.com/y4mqoYRMjdbPgMLpg9E7NIsGsZqu6viE97lZEMMAth4wMzQpJZI1m_4hrYe7PdLgt1ZiaugHcTiKufb_kryRKdPUsqeMdAcdTcxQ9QmXdvSJ68fAbjjtnc0zJIl5GUs4aQWYBzvBIOBv7NnzNC0dLIH7ue6E_mSAnRPonBbY85URPCOK2i-rHGzF-CEuVNRsoOCnRfcgcFbgQNPlF_SRN_1xw?width=344&height=332&cropmode=none" width="40%" high="40%"/><br>图1  Django 目录结构</center><ul><li>Django使用的入口文件：<code>manage.py</code></li><li>Django的配置文件：<code>settings.py</code>，配置文件的内容：<ol><li>项目路径；</li><li>密钥；</li><li>域名访问权限；</li><li>App列表；</li><li>静态资源，如CSS、JaveScript、图片等；</li><li>模板文件；</li><li>数据库配置；</li><li>缓存；</li><li>中间件；</li></ol></li><li>Django URL调度器：<code>url.py</code>，URL调度器流程：<ol><li>传入HttoRequest对象，Django中间件设置urlconf属性；</li><li>加载URLconf模块，寻找可用urlpatterns，支持正则匹配；</li><li>匹配成功，Django调用相关视图，传入如下参数：<ol><li>一个HttpRequest实例；</li><li>一个或多个位置参数；</li></ol></li><li>匹配失败，抛出异常，可定制；</li></ol></li></ul><pre><code class="Py"># 例程1path(&#39;&lt;int:year&gt;&#39;, views.year),  #只接收整数，否则将返回404，页面不存在{  path(&#39;&lt;int:year&gt;/&lt;str:name&gt;&#39;, views.name) #site/year/name  def name(request, **kwargs):    return HttpResponse(kwargs[&#39;name&#39;])}# 例程2re_path(&#39;(?P&lt;year&gt;[0-9]{4}).html&#39;, views.myyear, name=&#39;urlyear&#39;)# 例程3from . import convertersregister_converter(converters.IntConverter, &#39;myint&#39;)path(&#39;&lt;myint:year&gt;&#39;, views.year)class IntConverter:    regex = &#39;[0-9]+&#39;    def to_python(self, value):        return int(value)    def to_url(self, value):        return str(value)</code></pre><ul><li>Django URL变量支持：<ol><li>带变量的URL，支持五种<code>str/int/slug/uuid/path</code>，如例程1所示；</li><li>正则表达式处理，使用例程2中的代码将返回index文件夹中Templates文件夹内的yearview.html；</li><li>自定义函数，如例程3所示，首先注册自定义的转换，在converters.py中定义IntConverter类。</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Django基础&quot;&gt;&lt;a href=&quot;#Django基础&quot; class=&quot;headerlink&quot; title=&quot;Django基础&quot;&gt;&lt;/a&gt;Django基础&lt;/h2&gt;&lt;h3 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="技术笔记" scheme="http://sioce.me/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Django" scheme="http://sioce.me/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>虚函数</title>
    <link href="http://sioce.me/2020/08/21/%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    <id>http://sioce.me/2020/08/21/%E8%99%9A%E5%87%BD%E6%95%B0/</id>
    <published>2020-08-21T07:43:29.000Z</published>
    <updated>2020-08-24T07:39:58.694Z</updated>
    
    <content type="html"><![CDATA[<h2 id="继承搭配虚函数"><a href="#继承搭配虚函数" class="headerlink" title="继承搭配虚函数"></a>继承搭配虚函数</h2><a id="more"></a><h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><ul><li><strong>多态polymorphism</strong>：面向对象的一大特点，<strong>虚函数</strong>是实现多态的机制：<ol><li><strong>理念</strong>：通过基类访问派生类定义的函数；</li><li>多态使得程序再运行时决定调用的函数(<em>动态联编</em>)，而非编译时静态确定；</li><li>经典应用场景：使用基类的引用或指针指向子类的对象，进而调用子类覆写的虚函数；</li></ol></li><li>成员函数分类：<ol><li><strong>非虚函数</strong>，不希望派生类重新定义；</li><li><strong>虚函数</strong>，使用<code>virtual</code>声明，希望派生类重新定义，可以不覆写；</li><li><strong>纯虚函数</strong>，定义<code>virtual void func() = 0</code>，要求派生类必须重新定义；</li></ol></li></ul><pre><code class="C++">//例程1class C{public:    void func1();    void func2();    int data;}class C{public:    void func3();    virtual void func4();    int var;}</code></pre><center><img src="https://qbacua.bl.files.1drv.com/y4m8fGFIljEUSw17ZwLrsLMM8Xp8p5cZ5U29L3FNzQO8jKhelxmSlaFhHPdwxnkJPNibCXDphPIFl7RZt4t3pmcMfLg8dMKaI-CUPddcSz1Rv2f8exsJFnJaoQNrLLKZUTUuvYa-GhPWupTZCZxMw5oeYGhMB3dkTDOH4ibXzG4lal3dzn7dWEC0-Ljwigvmjqgs8Kq3ZqoQO5rLlq7NatgGw?width=314&height=326&cropmode=none" width="40%" /><br>图1  例程1内存布局</center><ul><li><p>例程1再内存中的布局如图1所示：</p><ol><li>成员函数(普通函数、虚函数)为类的所有对象共有，另外虚函数表也是共有的；</li><li>成员变量为类的每个对象私有，另外虚函数表指针也是私有的；</li><li>实现虚函数的关键：<strong>虚函数表指针vptr</strong>，它指向存储再全局数据区的<em>虚函数表</em>，表中存放函数的指针</li><li>指针类型决定普通函数的调用，虚函数指针决定虚函数的调用；</li></ol></li><li><p><strong>纯虚函数</strong>：</p><ol><li>理论上，由将基类实例化是不合理的；</li><li>基类中声明的纯虚函数被子类覆写后就成为虚函数；</li><li>纯虚函数为基类定义的<strong>接口</strong>，用于规范子类的行为；</li><li>含有纯虚函数的类称为<strong>抽象类</strong>，不能实例化；</li><li>若派生类未覆写基类的纯虚函数，则该派生类仍为抽象类；</li></ol></li><li><p>构造函数和析构函数：</p><ol><li>构造函数不能为虚函数；</li><li>析构函数可以是虚函数，且<em>推荐声明为虚函数。</em></li><li>另外：内联函数和静态成员函数均不能是虚函数；</li></ol></li><li><p>C++提供两种多态性：</p><ol><li><strong>编译时多态性(静态多态)</strong>，通过重载虚函数实现——先期联编；</li><li><strong>运行时多态性(动态多态)</strong>，通过虚函数实现——滞后联编；</li></ol></li><li><p>C++的隐藏：</p><ol><li>派生类的函数和基类函数重名，但参数不同。此时无论是否有<code>virtual</code>关键字，基类函数被隐藏；</li><li>如果基类函数与派生类函数不仅同名，而且参数也相同，但基类函数没有<code>virtual</code>关键字声明，基类函数将被隐藏。</li><li><strong>注意</strong>：重载是在同一个类中发生的。</li></ol></li></ul><pre><code class="C++">//例程1class Shape{public:    virtual void draw() const  = 0; //pure virtual    virtual void error(const std::string&amp; msg); //impure virtual    int objectID() const; //non-virtual}</code></pre><ul><li>数据可以被继承，这从内存方面很好理解。另外函数也可以继承，理解函数的继承需要从调用权切入。</li><li>分类：<ol><li>非虚函数，</li><li>虚函数：希望派生类重新定义，而且基类中存在虚函数的默认定义；</li><li>纯虚函数：子类一定要重新定义(可以有定义)。</li></ol></li><li>虚函数只能借助于指针或者引用来达到多态的效果。</li><li>含有纯虚拟函数的类称为抽象类，它不能生成对象。</li><li>多态（polymorphism）是面向对象编程语言的一大特点，而虚函数是实现多态的机制。其核心理念就是通过基类访问派生类定义的函数。</li><li>当使用类的指针调用成员函数时，普通函数由指针类型决定，而虚函数由指针指向的实际类型决定；</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;继承搭配虚函数&quot;&gt;&lt;a href=&quot;#继承搭配虚函数&quot; class=&quot;headerlink&quot; title=&quot;继承搭配虚函数&quot;&gt;&lt;/a&gt;继承搭配虚函数&lt;/h2&gt;
    
    </summary>
    
    
      <category term="技术笔记" scheme="http://sioce.me/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://sioce.me/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>组合与继承</title>
    <link href="http://sioce.me/2020/08/21/%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF/"/>
    <id>http://sioce.me/2020/08/21/%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF/</id>
    <published>2020-08-21T06:42:02.000Z</published>
    <updated>2020-08-21T07:45:07.208Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类之间的三种关系"><a href="#类之间的三种关系" class="headerlink" title="类之间的三种关系"></a>类之间的三种关系</h2><a id="more"></a><ul><li><strong>复合(Composition)</strong></li><li><strong>委托(Delegation)</strong></li><li><strong>继承</strong></li></ul><h3 id="复合"><a href="#复合" class="headerlink" title="复合"></a>复合</h3><pre><code class="C++">// 例程1tmplate &lt;class T&gt;class queue {    ···protected:    deque&lt;T&gt; c;public:    bool empty() const {return c.empty();}    ···};//构造 内部的Component构造亦可以使用非默认Container::Container(...): Component() {...};//析构Container::~Container(...) {... ~Component() };</code></pre><center><img src="" width="40%" /><br>图1  复合示意图</center><ul><li>例程1展示了一个复合的例子，其中<code>queue</code>类包含了<code>deque</code>，这种操作在设计模式称为<strong>适配器</strong>;</li><li>复合关系下的构造和析构：<ol><li><strong>构造由内而外</strong>，Container构造函数首先调用Component的默认构造函数，然后才执行自己的构造函数；</li><li><strong>析构由外而内</strong>，即限制性自己的构造函数，再调用Component的析构函数。</li></ol></li><li>复合关系下，queue和deque的生命同时出现；</li></ul><h3 id="委托-Composition-by-reference"><a href="#委托-Composition-by-reference" class="headerlink" title="委托(Composition by reference)"></a>委托(Composition by reference)</h3><pre><code class="C++">//例程2class StringRep { // Bodyfriend class String;    StringRep(const char* s);    ~StringRep();    int count;    char* rep;};class String { //Handlepublic:    String();    String(const char* s);    ~String();    ···private:    StringRep* rep; //pimpl(Pointer to Implementation)}</code></pre><center><img src="" width="40%" /><br>图2  委托示意图</center><ul><li>图二中是一个共享模型，其中n计算当前由多少个对象共享自身，当a试图改变R时，不能直接更改，需要进行拷贝之后再更改，防止影响引用a、b。</li></ul><h2 id="继承-Inheritance"><a href="#继承-Inheritance" class="headerlink" title="继承(Inheritance)"></a>继承(Inheritance)</h2><pre><code class="C++">//例程3struct _List_node_base{    _List_node_base* _M_next;    _List_node_base* _M_prev;}template&lt;typename _Tp&gt;struct _List_node: publiv _List_node_base{    _TP _M_data;}</code></pre><ul><li>继承需要结合虚函数使用方可发挥最大功效；</li><li>基类的析构函数必须为虚函数</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;类之间的三种关系&quot;&gt;&lt;a href=&quot;#类之间的三种关系&quot; class=&quot;headerlink&quot; title=&quot;类之间的三种关系&quot;&gt;&lt;/a&gt;类之间的三种关系&lt;/h2&gt;
    
    </summary>
    
    
      <category term="技术笔记" scheme="http://sioce.me/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://sioce.me/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>访问权限控制</title>
    <link href="http://sioce.me/2020/08/21/%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/"/>
    <id>http://sioce.me/2020/08/21/%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/</id>
    <published>2020-08-21T06:29:36.000Z</published>
    <updated>2020-08-21T07:44:34.996Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关键字public-private-protected"><a href="#关键字public-private-protected" class="headerlink" title="关键字public/private/protected"></a>关键字public/private/protected</h2><a id="more"></a><h3 id="修饰类成员"><a href="#修饰类成员" class="headerlink" title="修饰类成员"></a>修饰类成员</h3><ul><li>C++类中的成员(函数/变量)拥有三种访问权限：<ol><li><strong>public</strong>，用该关键字修饰的成员表示<strong>公有成员</strong>，该成员不仅可以在类内可以被访问，在类外也是可以被访问的，是类对外提供的可访问接口；</li><li><strong>private</strong>，用该关键字修饰的成员表示<strong>私有成员</strong>，该成员仅在类内可以被访问，在类体外是隐藏状态；</li><li><strong>protected</strong>，用该关键字修饰的成员表示<strong>保护成员</strong>，保护成员在类体外同样是隐藏状态，但是对于该类的派生类来说，相当于公有成员，在派生类中可以被访问。</li></ol></li></ul><h3 id="修饰继承"><a href="#修饰继承" class="headerlink" title="修饰继承"></a>修饰继承</h3><ul><li>一个类的派生类，不仅包含了基类的所有成员，还增加了自己的新成员。从基类中继承的成员的访问权限就相对较为复杂，具体取决于继承方式：<ol><li><strong>public</strong>，基类成员在派生类中的访问权限保持不变，也就是说，基类中的成员访问权限，在派生类中仍然保持原来的访问权限；</li><li><strong>private</strong>，基类所有成员在派生类中的访问权限都会变为私有(private)权限；</li><li><strong>protected</strong>，基类的公有成员和保护成员在派生类中的访问权限都会变为保护(protected)权限，私有成员在派生类中的访问权限仍然是私有(private)权限。</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;关键字public-private-protected&quot;&gt;&lt;a href=&quot;#关键字public-private-protected&quot; class=&quot;headerlink&quot; title=&quot;关键字public/private/protected&quot;&gt;&lt;/a&gt;关键字public/private/protected&lt;/h2&gt;
    
    </summary>
    
    
      <category term="技术笔记" scheme="http://sioce.me/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://sioce.me/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>static关键字</title>
    <link href="http://sioce.me/2020/08/20/static%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://sioce.me/2020/08/20/static%E5%85%B3%E9%94%AE%E5%AD%97/</id>
    <published>2020-08-20T09:18:50.000Z</published>
    <updated>2020-08-21T07:45:13.928Z</updated>
    
    <content type="html"><![CDATA[<h2 id="static关键字的使用分类"><a href="#static关键字的使用分类" class="headerlink" title="static关键字的使用分类"></a>static关键字的使用分类</h2><a id="more"></a><ul><li>静态成员变量（面向对象）</li><li>静态成员函数（面向对象）</li><li>静态全局变量（面向过程）</li><li>静态局部变量（面向过程）</li><li>静态函数（面向过程）</li></ul><h3 id="静态成员变量"><a href="#静态成员变量" class="headerlink" title="静态成员变量"></a>静态成员变量</h3><ul><li>类中，使用static修饰的成员变量，他的特点如下：<ol><li>它为类的所有实例对象拥有，只有一份；</li><li>静态成员变量不占用类实例化对象的内存，类未实例化其静态变量即存在，可以对之进行操作。</li><li>静态成员变量存储在全局数据区，其内存在初始化时分配且初始化必须在类体外进行。初始化时，如果不赋值则默认为0，静态数据区的变量一般都有默认值，而动态数据区(堆、栈)的默认值都是垃圾值。</li><li>静态成员初始化与一般成员初始化不同。初始化时可以不加<code>static</code>，但必须要有数据类型。被<code>private</code>、<code>protected</code>、<code>public</code>修饰的 <code>static</code>成员变量都可以用这种方式初始化。静态数据成员初始化的格式为：＜数据类型＞＜类名＞::＜静态数据成员名＞=＜值＞</li><li>类的静态成员变量访问形式:<ul><li>＜类对象名＞.＜静态数据成员名＞;</li><li>＜类类型名＞::＜静态数据成员名＞;</li></ul></li><li>静态数据成员和普通数据成员一样遵从<code>public</code>,<code>protected</code>,<code>private</code>访问规则；</li><li>sizeof 运算符不会计算 静态成员变量。</li></ol></li><li>优点：<ol><li>不会与存在于全局空间中标识符冲突；</li><li>隐藏信息，可以使用<code>private</code>保护，而全局不能；</li></ol></li></ul><h3 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h3><ul><li>与普通函数相比，静态成员函数属于类本身，而不作用于对象，因此它不具有this指针；</li><li>无法访问属于类对象的非静态成员变量和非静态成员函数，只能调用其余的静态成员函数和静态成员变量；</li><li>特点：<ol><li>静态成员之间可以相互访问，即静态成员函数（仅）可以访问静态成员变量、静态成员函数；</li><li>非静态成员函数可以任意地访问静态成员函数和静态数据成员；</li><li>由于没有this指针的额外开销，静态成员函数与类的全局函数相比速度上会稍快；</li><li>调用静态成员函数，两种方式：<ul><li>通过成员访问操作符(.)和(-&gt;)；</li><li>直接通过类来调用静态成员函数。＜类名＞::＜静态成员函数名＞</li></ul></li></ol></li></ul><h3 id="静态全局变量"><a href="#静态全局变量" class="headerlink" title="静态全局变量"></a>静态全局变量</h3><ul><li>在全局变量前，加上关键字static，该变量就被定义成为一个静态全局变量。</li><li>特点：<ol><li>该变量在全局数据区分配内存；</li><li>未经初始化的静态全局变量会被程序自动初始化为0；</li><li>静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见的；</li><li>静态变量都在全局数据区分配内存，包括后面将要提到的静态局部变量。</li></ol></li><li>定义静态全局变量还有以下优点：<ol><li>静态全局变量不能被其它文件所用；</li><li>其它文件中可以定义相同名字的变量，不会发生冲突；</li></ol></li></ul><h3 id="静态局部变量"><a href="#静态局部变量" class="headerlink" title="静态局部变量"></a>静态局部变量</h3><ul><li>在局部变量前，加上关键字static，该变量就被定义成为一个静态局部变量。</li><li>静态局部变量保存在全局数据区，而不是保存在栈中，每次的值保持到下一次调用，直到下次赋新值。</li><li>静态局部变量有以下特点：<ol><li>静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化；</li><li>静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0；</li><li>静态局部变量始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束；</li></ol></li></ul><h3 id="静态函数"><a href="#静态函数" class="headerlink" title="静态函数"></a>静态函数</h3><ul><li>静态函数与普通函数不同，它只能在声明它的文件当中可见，不能被其它文件使用。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;static关键字的使用分类&quot;&gt;&lt;a href=&quot;#static关键字的使用分类&quot; class=&quot;headerlink&quot; title=&quot;static关键字的使用分类&quot;&gt;&lt;/a&gt;static关键字的使用分类&lt;/h2&gt;
    
    </summary>
    
    
      <category term="技术笔记" scheme="http://sioce.me/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://sioce.me/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>内存管理</title>
    <link href="http://sioce.me/2020/08/20/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://sioce.me/2020/08/20/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2020-08-20T07:56:13.000Z</published>
    <updated>2020-08-21T07:44:50.996Z</updated>
    
    <content type="html"><![CDATA[<h2 id="堆-amp-栈"><a href="#堆-amp-栈" class="headerlink" title="堆&amp;栈"></a>堆&amp;栈</h2><a id="more"></a><ul><li><strong>堆</strong>，由操作系统提供的一块全局内存空间，程序可动态分配从其中取若干区块存放数据；</li><li><strong>栈</strong>，存在于某作用域的一块内存空间，比如调用函数即形成一个栈存放其所接收的参数以及返回地址；<ol><li>离开作用域，站内变量生命周期即结束。</li><li>作用域中<code>static</code>声明的变量在作用域结束后依然存在；</li></ol></li></ul><h2 id="手动分配内存"><a href="#手动分配内存" class="headerlink" title="手动分配内存"></a>手动分配内存</h2><pre><code class="C++">// 例程1Complex* pc = new Complex(1, 3); //p1//代码p1的剖析——编译器分解后的代码void* mem = operator new( sizeof(Complex) ) //申请空间 底层调用mallocpc = static_cast&lt;Complex*&gt;(mem); //类型转换pc-&gt;Complex::Complex(1, 3);  //调用构造函数</code></pre><ul><li>例程1展示<code>new</code>的底层操作；</li></ul><pre><code class="C++">// 例程2String* ps = new String(&quot;Hello&quot;);···delete ps;//代码p1的剖析——编译器分解后的代码String::~String(ps); //删除动态分配空间operator delete(ps); //底层调用free</code></pre><ul><li>例程2展示<code>delete</code>的底层操作；</li></ul><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><pre><code class="C++">// 例程3class data {public:    func();private:    int *a;    int *b;}String* p = new data[3];         //p1···                              //p2delete[] p; // 调用三次析构函数  //p3</code></pre><center><img src="../../themes/mem-mana.png" width="40%" /><br>图1  data对象占用内存</center><center><img src="../../themes/mem_mana2.png" width="40%" /><br>图2  data数组占用空间</center><ul><li>在VC中创建一个data对象将分配图1所示内存：</li><li>在VC中创建一个data数组将分配图2所示内存：</li><li>例程3中，代码p1-p3必须组合出现。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;堆-amp-栈&quot;&gt;&lt;a href=&quot;#堆-amp-栈&quot; class=&quot;headerlink&quot; title=&quot;堆&amp;amp;栈&quot;&gt;&lt;/a&gt;堆&amp;amp;栈&lt;/h2&gt;
    
    </summary>
    
    
      <category term="技术笔记" scheme="http://sioce.me/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://sioce.me/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>三大函数</title>
    <link href="http://sioce.me/2020/08/19/%E4%B8%89%E5%A4%A7%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    <id>http://sioce.me/2020/08/19/%E4%B8%89%E5%A4%A7%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</id>
    <published>2020-08-19T14:26:31.000Z</published>
    <updated>2020-08-20T07:56:18.877Z</updated>
    
    <content type="html"><![CDATA[<pre><code class="C++">// 例程1class String {public:    inline String(const char* catr = 0); // 构造函数    String(const String&amp; str); // 拷贝构造函数    String&amp; operator = (const String&amp; str)； // 拷贝复制函数    ~String()； // 析构函数private:    char* m_data;}</code></pre><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><pre><code class="C++">// 例程2inline String::String(const char* cstr = 0) {    if(cstr) {        m_data = new char[strlen(cstr) + 1];        strcpy(m_data, cstr);    }    else {        m_data = new char[1];        *m_data = &#39;\0&#39;    }}inline String::~String() {    delete[] m_data;}</code></pre><ul><li>成员函数中动态分配内存，必须在析构函数中主动释放；</li></ul><h2 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h2><center><img src="../../themes/ctor.gif" width="80%" /><br>图1  默认拷贝构造函数</center><pre><code class="C++">// 例程3inline String::String(const String&amp; str) {    m_data = new char[strlen(str.m_data) + 1];    strcpy(m_data, str.m_data); //深拷贝}</code></pre><ul><li><strong>拷贝构造函数</strong>是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。<ol><li>通过使用另一个同类型的对象来初始化新创建的对象。</li><li>复制对象把它作为参数传递给函数。</li><li>复制对象，并从函数返回这个对象。</li></ol></li><li>如果在类中没有定义拷贝构造函数，编译器会自行定义一个。如果类带有指针变量，并有动态内存分配，则它必须自定义拷贝构造函数。<ol><li>默认拷贝构造函数的行为是仅拷贝成员变量的值；</li></ol></li></ul><h2 id="拷贝复制函数"><a href="#拷贝复制函数" class="headerlink" title="拷贝复制函数"></a>拷贝复制函数</h2><pre><code class="C++">// 例程4inline String&amp; String::operator = (const String&amp; str) {    if(this == &amp;str) return *this; //检测自我复制，此处不可或缺    delete[] m_data; //删除自己占用内存；    m_data= new char(strlen(str) + 1) //申请内存存放复制内容    strcpy(m_data, str.m_data);    return *this;}</code></pre><ul><li>拷贝复制函数：<ol><li>检查是否为自我复制；</li><li>删除自身占据的空间；</li><li>申请新空间；</li><li>将内容复制到申请到的空间中；</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code class=&quot;C++&quot;&gt;// 例程1
class String {
public:
    inline String(const char* catr = 0); // 构造函数
    String(const String&amp;amp; str); // 
      
    
    </summary>
    
    
      <category term="技术笔记" scheme="http://sioce.me/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://sioce.me/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>操作符重载&amp;空对象</title>
    <link href="http://sioce.me/2020/08/19/%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD-%E7%A9%BA%E5%AF%B9%E8%B1%A1/"/>
    <id>http://sioce.me/2020/08/19/%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD-%E7%A9%BA%E5%AF%B9%E8%B1%A1/</id>
    <published>2020-08-19T13:25:00.000Z</published>
    <updated>2020-08-21T07:44:26.888Z</updated>
    
    <content type="html"><![CDATA[<h2 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h2><a id="more"></a><h3 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h3><pre><code class="C++">// 例程1inline complex&amp; __doapl(complex* ths, const complex&amp; r) {    this-&gt;re += r.re;    this-&gt;im += r.im;    return *this;}inline complex&amp;complex::operator += (const complex&amp; r) {    return __doapl(this, r);  //注意this不能写入成员函数参数，但可以在成员函数内使用}// 下述代码要求操作符重载函数的返回值必须为complexc1 += c2 += c3;</code></pre><ul><li>所有的成员函数都带有一个隐藏的参数——<strong>this</strong>，请不要主动写出来，如例程1所示；</li><li>例程1中<code>__doapl()</code>函数返回值为值，而函数限定的返回值为引用，函数依然可以正常工作，由此可知——<strong>传递者无需知道接收者的接收形式</strong>；</li></ul><h3 id="非成员函数"><a href="#非成员函数" class="headerlink" title="非成员函数"></a>非成员函数</h3><pre><code class="C++">// 例程2inline complex operator + (const complex&amp; x, const complex&amp; y) {    return complex（real(x) + real(y), imag(x) + imag(y));}inline complex operator + (const complex&amp; x,double y);inline complex operator + (double x, const complex&amp; y);// 操作符+重载函数的多态inline complex operator + (const complex&amp; x) {  //注意这里可以返回值可以是引用    return x; }</code></pre><ul><li>注意例程2中的返回值<code>inline complex operator</code>不能是引用，因为函数体中返回的内容只是一个<strong>临时对象</strong>，他的生命周期随着语句的完成而结束；</li></ul><h3 id="成员函数-vs-非成员函数"><a href="#成员函数-vs-非成员函数" class="headerlink" title="成员函数 vs 非成员函数"></a>成员函数 vs 非成员函数</h3><pre><code class="C++">// 例程3inline complex conj(const complex&amp; x) {    return complex(real(x), -imag(x));}#include &lt;iostream.h&gt;ostream&amp; operator &lt;&lt; (ostream&amp; os, const complex&amp; x) {    return os &lt;&lt; &#39;(&#39; &lt;&lt; real(x) &lt;&lt; &#39;,&#39; &lt;&lt; imag(x) &lt;&lt; &#39;)&#39;;}// &#39;&lt;&lt;&#39;操作符作用于cout，cout相当于重载函数的形参oscout &lt;&lt; conj(c1);</code></pre><ul><li>具体选择使用那种函数，需要根据需求设计。<ol><li>赋值 = 、下标[ ]、调用( )、和成员访问箭头 -&gt;必须是成员函数；</li><li>复合赋值运算符应该是成员，但是并非必须；</li><li>改变对象状态的运算符或者与给定类型密切相关的运算符，如 递增、递减和解引用运算符应该是成员；</li><li>具有对称性的运算符可能转换任一端的运算对象，例如算数、相等性、关系和位运算符等，因此通常应该是普通的非成员函数。</li></ol></li><li>重载运算符为成员函数后,当调用该运算符时,左操作数必须是该类的实例。</li><li>如例程3所示，输出操作符<code>&lt;&lt;</code>的重载必须设计为非成员函数。<ul><li>如果将<code>&lt;&lt;</code>重载为成员函数，则用法为<code>obj_class &lt;&lt; cout</code>，不符合常规。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;操作符重载&quot;&gt;&lt;a href=&quot;#操作符重载&quot; class=&quot;headerlink&quot; title=&quot;操作符重载&quot;&gt;&lt;/a&gt;操作符重载&lt;/h2&gt;
    
    </summary>
    
    
      <category term="技术笔记" scheme="http://sioce.me/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://sioce.me/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>面试题目</title>
    <link href="http://sioce.me/2020/08/17/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"/>
    <id>http://sioce.me/2020/08/17/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/</id>
    <published>2020-08-17T12:05:49.000Z</published>
    <updated>2020-08-17T12:20:56.085Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-多态"><a href="#C-多态" class="headerlink" title="C++多态"></a>C++多态</h2><ul><li>多态是面向对象的特征，基本定义为‘一个接口，多种状态’，分为两种：<ol><li><strong>静态多态</strong>：编译阶段即将函数实现和函数调用相关联，即地址早绑定。</li><li><strong>动态多态</strong>：运行阶段将函数实现和函数调用相关联，即地址晚绑定。</li></ol></li><li>多态的作用是<strong>接口重用</strong>：<ol><li>静态多态，将同一个接口进行不同的实现，根据传入参数的不同调用不同的实现；</li><li>动态多态，不论传递哪个类的对象，函数都能通过同一个接口调用各自对象实现的方法；</li></ol></li><li>多态的实现：<ol><li>静态多态通过函数的重载和模板编程实现；</li><li>动态多态常见用法是声明基类的指针，并将其指向子类的对象，调用相应的虚函数，可以根据指向子类的不同调用不同的方法。</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;C-多态&quot;&gt;&lt;a href=&quot;#C-多态&quot; class=&quot;headerlink&quot; title=&quot;C++多态&quot;&gt;&lt;/a&gt;C++多态&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;多态是面向对象的特征，基本定义为‘一个接口，多种状态’，分为两种：&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;静态多态
      
    
    </summary>
    
    
      <category term="面试" scheme="http://sioce.me/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://sioce.me/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>古文观赏</title>
    <link href="http://sioce.me/2020/08/14/%E5%8F%A4%E6%96%87%E8%A7%82%E8%B5%8F/"/>
    <id>http://sioce.me/2020/08/14/%E5%8F%A4%E6%96%87%E8%A7%82%E8%B5%8F/</id>
    <published>2020-08-14T11:07:54.000Z</published>
    <updated>2020-08-14T11:09:06.410Z</updated>
    
    <content type="html"><![CDATA[<h2 id="项脊轩志"><a href="#项脊轩志" class="headerlink" title="项脊轩志"></a>项脊轩志</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;项脊轩志&quot;&gt;&lt;a href=&quot;#项脊轩志&quot; class=&quot;headerlink&quot; title=&quot;项脊轩志&quot;&gt;&lt;/a&gt;项脊轩志&lt;/h2&gt;
      
    
    </summary>
    
    
      <category term="兴趣" scheme="http://sioce.me/categories/%E5%85%B4%E8%B6%A3/"/>
    
    
      <category term="古文" scheme="http://sioce.me/tags/%E5%8F%A4%E6%96%87/"/>
    
  </entry>
  
</feed>
