{"meta":{"title":"Fujie's Blog","subtitle":"学习&生活","description":"","author":"Fujie","url":"http://sioce.me","root":"/"},"pages":[{"title":"about","date":"2020-07-28T07:33:12.000Z","updated":"2020-07-28T14:10:24.169Z","comments":true,"path":"about/index.html","permalink":"http://sioce.me/about/index.html","excerpt":"","text":"About不断学习，保持热爱！ Contact Me🕸 github: F-jie📧 email: 163"},{"title":"archives","date":"2020-07-28T09:32:00.000Z","updated":"2020-07-28T09:32:00.735Z","comments":true,"path":"archives/index.html","permalink":"http://sioce.me/archives/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-07-28T09:31:48.000Z","updated":"2020-07-28T09:31:48.748Z","comments":true,"path":"categories/index.html","permalink":"http://sioce.me/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-07-28T07:33:23.000Z","updated":"2020-07-28T07:33:23.954Z","comments":true,"path":"tags/index.html","permalink":"http://sioce.me/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-07-28T09:33:43.000Z","updated":"2020-07-28T09:33:43.791Z","comments":true,"path":"categories/index-1.html","permalink":"http://sioce.me/categories/index-1.html","excerpt":"","text":""}],"posts":[{"title":"OS virtualization","slug":"OS-virtualization","date":"2020-07-29T13:44:46.000Z","updated":"2020-07-29T14:48:04.651Z","comments":true,"path":"2020/07/29/OS-virtualization/","link":"","permalink":"http://sioce.me/2020/07/29/OS-virtualization/","excerpt":"","text":"第一章 操作系统简介 冯·诺伊曼计算机模型：取指令、解码、运行。 操作系统使程序的运行更加容易，且高效正确。为了实现这一目的，操作系统需要使用虚拟化技术——即将物理资源转化为更通用、更强大且易于使用的虚拟形式。用户使用操作系统提供的API访问硬件资源。 虚拟化CPU，这使得系统在只有一个处理器的前提下同时运行多个程序，为了控制程序的开始和结束，需要使用相关的接口，向操作系统传递需求。操作系统的策略将会控制特定时间运行哪个程序——这由操作系统的基本机制决定。 虚拟化内存，现代机器提供的物理内存就是一个字节数组，读数据需要指定地址，写数据需要指定地址和数据。操作系统虚拟化内存时，每个进程访问私有的虚拟地址空间，OS以某种方式将该地址空间映射到机器的物理内存上。 并发问题，这一问题首先出现在操作系统本身上，此外在现代多线程程序中也存在这样的问题； 持久性，内存中的数据需要依靠硬件和软件辅助存储，硬件通常指磁盘，软件则为文件系统，软件负责将用户创建的内容存储到硬盘中。 操作系统会提供CPU和内存的抽象，但不会为每个应用程序创建虚拟磁盘； 总结：操作系统取得CPU、内存以及磁盘等物理资源，并对之进行虚拟化；处理并发可能引起的问题；对文件进行持久化存储。这些过程最重要的是抽象，抽象是编写大型程序必不可少的部分。 操作系统设计的目标： 高性能，操作系统的开销以额外的时间和空间的形式出现，但必须容忍不完美； 提供程序间以及OS和程序间的保护，为了实现这一目标，隔离是一种基本原理； 可靠性：事实上，这方面有许多正在进行的研究； 其他目标主要有：能源效率、安全性和移动性等。 第四章 操作系统的基本抽象——进程 进程的非正式定义——运行中的程序 为了实现CPU的虚拟化，需要使用分时共享CPU技术，虽然不可避免的引入潜在的性能损失但很值得。实现优秀的CPU虚拟化，需要搭配使用低级机制和高级智能： 低级机制——机制(mechanism)，如上下文切换； 高级智能——策略(policy)，这指的是操作系内的决定算法； 进程的机器状态对理解进程的构成十分重要： 机器状态一——地址空间，即内存，内存中保存着程序的指令、读取的数据等； 机器状态二——寄存器，许多指令需要对寄存器进程读写； 机器状态三——程序计数器(指令指针，IP)； 进程API 创建(create) 销毁(destroy) 等待(wait) 其他控制(miscellaneous control) 状态(status) 进程的创建，程序-&gt; -&gt;进程： 操作系统加载代码和静态数据至内存中属于进程的地址空间；(现代操作系统惰性执行该过程，这涉及到分页和交换机制——内存虚拟化)； 为程序的运行时栈分配内存，C语言拥栈保存局部变量、函数参数和返回地址； 为程序的堆分配内存，C语言中堆用于存储显示动态分配数据，数据结构也需要堆，堆的大小会变化； 为输入输出任务创建三个文件描述符，用于标准的输入输出以及错误。 进程的状态： 运行：正在处理器上执行； 就绪：等待被调用； 阻塞：等待某种操作完成。 数据结构，操作系统需要使用某些关键的数据结构跟踪相关的信息： 为所有就绪的进程保留进程列表； 跟踪正在运行进程的附加信息； 跟踪被阻塞进程； I/O完成时，正确地唤醒进程； 第五章 进程API UNIX系统使用一对系统调用fork()/exec()创建进程，另外进程还可以使用系统调用wait()等待其创建子进程执行完成； fork()系统调用：使用该系统调用创建子进程，子进程fork()调用的返回值为0，父进程fork()调用返回值为子进程PID； wait()系统调用，该系统调用在子进程运行结束后才返回； exec()系统调用，它还有其他几种变体：execl、execle、execlp、execv、execvp。假设使用execvp运行字符计数程序，exec会从可执行程序中加载代码和静态数据并覆写自己的代码段，堆栈及相应的地址空间也会重新初始化。 之所以设计fork和exec，是为了程序能够运行fork之后，exec之前构建的代码，比如shell，它首先显示命令提示符，等待用户输入，用户输入指令后，shell调用fork创建新的进程，再调用exec的某个变体执行命令中的可执行程序，最后调用wait等待该子进程结束，子进程结束后，shell再输出命令提示符； 重定向的实现原理：再创建子进程之后，关闭标准输入输出，同时打开重定向的文件，最后调用exec。 UNIX系统的管道，pipe()系统调用可以将一个进程的输出无缝连接到另一个进程的输入上，如grep -o foo file | wc -l","categories":[{"name":"OS","slug":"OS","permalink":"http://sioce.me/categories/OS/"}],"tags":[{"name":"OS","slug":"OS","permalink":"http://sioce.me/tags/OS/"}]},{"title":"computer network","slug":"computer-network","date":"2020-07-28T14:12:54.000Z","updated":"2020-07-30T09:28:28.144Z","comments":true,"path":"2020/07/28/computer-network/","link":"","permalink":"http://sioce.me/2020/07/28/computer-network/","excerpt":"","text":"分层一、 总分为七层，这里忽略应用层后的表示层和会话层 名称 协议 应用层 DHCP、HTTP、HTTPS、TRTMP、P2P、DNS、GTP、RPC 传输层 UDP、TCP 网络层 IMCP、IP、OSPF、BGP、IPSec、GRE 链路层 ARP、VLAN、STP 物理层 网络跳线 二、 网络层的IP地址和链路层的MAC地址虽均能唯一确定用户 但IP可能是动态分布的，用户可能随时下线，此时就需要使用MAC进行区分； MAC是早期局域网通信的产物； 之所以提出IP协议是因为MAC的查找效率低下，另外MAC地址是通过ARP协议获取的，不易处理广播风暴问题； 三、 关于网络分层的四个问题 TCP三次握手，MAC和IP对应什么操作？ 已知原始地址和目标地址，其间需通过两个中转站B、C，包在中转站时是如何知道最终目的地的呢？ 我们知道二层设备和三层设备，那么二层设备处理的包的内容是否包含第七层的的内容呢？ SSH登录公有云主机，都经历那些过程呢？ 解答：复杂的程序都是要分层的，网络协议同样如此，网络中的包可以由下层没上层，反之则不成立； 经过网口的网络包会被相应的程序处理(混杂模式)： 首先摘掉第二层的头进行比对，若MAC地址一致，则交给网络层处理； 其次摘掉第三层的头比对IP，不一致则进行转发，否则交给传输层处理； 再其次拿掉第四层的头，交给TCP或者UDP处理，若是一个正常的数据包，则交给监听相应端口的应用程序，若是发起或应答，则需要发送回复包。 二层设备仅处理链路层的MAC地址，三层设备另外需要处理网络层的IP地址； IP地址一、 查询IP地址的指令：ifconfig、ip addr、ipconfig二、 IP地址的分类 类别 头标识 网络号(bit) 主机号(bit) A 0 7 24 B 10 14 16 C 110 21 8 类别 头标识 其他 D 1110 多播组号(28) E 11110 留待后用(27) 类别 IP地址范围 最大主机数 私有IP地址范围 A 0.0.0.0-127.255.255.255 16777214 10.0.0.0-10.255.255.255 B 128.0.0.0-191.255.255.255 65534 172.16.0.0-172.31.255.255 C 162.0.0.0-233.255.255.255 254 192.168.0.0-192.168.255.255 由上表可见，A、B、C三类IP的主机数分配严重不均，因而出现了无类型域间选路(CIDR): CIDR将IP地址分为两部分，前面是网络号，后面是主机号，如10.100.122.2/24，24表示网络号长度； 和CIDR共存的是广播地址和子网掩码，如10.100.122.2/24对应的广播地址为10.100.122.255，子网掩码是255.255.255.0，向广播地址发送数据，则10.100.122.:中的所有机器都能收到；将IP和子网掩码进行与操作，即可得网络号。 工作中几乎不涉及IP分类，仅使用CIDR，但需要区分公有IP和私有IP。每个网段中的第一个地址往往是网络的出口地址，最后一个地址则是广播地址； 组播地址，使用这类地址，属于某个组的机器都能收到； MAC地址，它虽然是唯一的，但不具备大范围定位功能。它能避免组网过程中的冲突问题。 网络的状态标识(net_device flags)： UP：表示网卡启动； BROADCAST：表示网卡有广播地址，可发送广播包； MULTICAST：表示网卡可发送多播包； LOWER_UP：表示L1启动，即网线插入； MTU1500：表示最大传输单元，它属于第二层链路层概念，当MAC头加正文大于1500自己时，需要启动分片传输； queueing discipline：表示排队规则，内核通过网络接口发送数据，需要为该接口配置排队规则将数据包加入队列 pfifo：先入先出； pfifo-fast：它的队列包含三个波段，每个波段先入先出，根据服务类型TOC将数据包放入不同的波段； IP地址的分配一、 手动配置# 使用ifconfig sudo ifconfig eth1 10.0.0.1/24 sudo ifconfig eth1 up #使用iproute2 sudo ip addr add 10.0.0.1/24 dev eth1 sudo ip link set up eth1 二、 动态主机配置协议(DHCP)，主要机制 新机器使用IP0.0.0.0向目标IP255.255.255.255发送广播，内部使用UDP封装BOOTP； DHCP SERVER，收到广播，辨识MAC，向新机器分配IP，此过程成为DHCP Offer，DHCP Server同样使用0.0.0.0作为本机IP，向广播IP255.255.255.255发送包括IP在内的子网掩码、网关、IP租用期等数据。 新机器收到广播，向广播IP发送DHCP Request数据包，包括自身MAC、接受的IP、提供IP的DHCP服务器地址等，此时新机器的IP仍为0.0.0.0。 DHCP Server收到客户端DHCP Request，使用本机IP向客户机发送DHCP ACK消息，接受客户机选择。 在租用期过去一半时，客户机会向对应的DHCP Server发送DHCP Request消息，并根据服务器返回的ACK消息更新租用期限和TCP/IP参数。 三、 预启动执行环境(PXE)，使用PXE管理员可以自动给数据中心的服务器安装操作系统 操作系统的启动： 启动BIOS，读取硬盘MBR启动扇区，启动GRUB； GRUB加载内核、作为根文件系统initramfs文件； 内核启动，初始化操作系统； PXE在BIOS启动之后发挥作用，主要流程如下： PXE客户端放在BIOS中，通过BIOS将PXE加载到内存中； PXE客户端发起DHCP请求，HDHCP Server给PXE客户端分配IP，并告知其PXE服务器地址、启动文件位置； PXE客户端使用TFTP协议向TFTP服务器请求下载启动文件，所以PXE服务器上还需要配置TFTP服务器； PXE客户端根据收到的启动文件向TFTP服务器请求计算机配置信息文件，告知客户端内核、initramfs位置； PXE客户端请求内核文件和initramfs文件； PXE客户端启动操作系统内核。 MAC——媒体访问控制一、 网络中的第一层当局域网中只有一台计算机时，只需要使用交叉网线并配置IP、子网掩码、默认网关即可。当设备数量增加时，就需要使用集线器Hub，它工作在物理层，将收到的每一个字节复制到其他端口上。 二、 网络中的第二层——数据链路层 Hub采用广播的模式发送数据，面临一下问题： 谁发的包？谁接受包？ 多台设备同时发包的先后顺序？ 发送错误，如何处理？ 数据链路层负责解决上述问题： 多路访问解决问题二，主要算法有： 信道划分——分多个信道，互不干扰； 轮流协议——类似单双号限行； 随机接入协议——需要则发送，拥堵则错过高峰再进行发送，以太网即采用这种方式； 链路层地址负责解决问题一，该地址也叫做MAC地址，第二层网络包格式如下： 网络包中的类型大部分为IP数据包，其内部包含TCP、UDP、HTTP等的封装 × 目标MAC 源MAC 类型 数据 CRC 位数(bytes) 6 6 2 46~1500 4 类型 内容 0800 IP数据报 0806 ARP请求、应答 上表网络包中的循环冗余检测CRC用于解决问题三，使用XOR异或算法计算整个包再在发送的过程中是否出错。 如何获取目标机器的MAC地址？ARP协议： 当已知目标IP时，本机会首先查询本地ARP缓存，求MAC地址，找不到则发送ARP广播； 目标IP收到广播，在通过ARP广播发送自身MAC地址； ARP报文如ARP报文所示； 二层设备——交换机 Hub采用广播的方式将每个网络包复制到每个网口，浪费资源且易产生冲突，如果转发设备能够记忆每个网口对应主机的MAC地址，这种情况就能得到缓解，这就是交换机； 通过不断学习，交换机会维护一个转发表，注意转发表也是有过期时间的； 三、 多台交换机——拓扑结构 拓扑结构中的环路问题示意图; STP协议——计算机网络中的生成树算法 基本概念有： 根交换机(Root Bridge)：某棵树的老大，类似掌门； 指定交换机(Designated Bridge)：拜此交换机做大哥的的交换机，也是此交换机大哥的小弟； 网桥协议数据单元(BPDU)：比较实力的协议； 优先级向量(Priority Vector)：实力； 工作过程： 起初所有的交换机都以自己为掌门，但网络管理员会根据交换机的性能给交换机分配高优先级； 所有的交换机互相发送BPDU，进行比较，形成小的从属关系； 掌门遇掌门，根据优先级决定门派合并； 掌门与小弟，根据距离决定汇报路径； 同门遇同门，比较与小弟距离决定从属关系； 掌门与外派小弟，比较掌门优先级； 非同门小弟相遇，比较掌门优先级； 广播问题和安全问题： 为了保障广播的安全和流畅问题，有两种解决方案： 物理隔离，每个部门设置单独交换机、单独子网，部门间使用路由器交流； 虚拟隔离，即VLAN虚拟局域网，在原来二层头的基础上增加一个TAG，一共12位，交换机取下二层头，检测VLAN，根据VLAN的值决定是否进行转发。这样这需要配置交换机每个网口的VLAN值即可实现虚拟隔离；此时交换机之间的连接口叫做Trunck口，它可以转发属于任何VLAN的口； 网络层一、 IMCP协议 ping指令就是基于IMCP协议工作的。IMCP全称互联网控制报文协议。互联网的状况复杂，需要根据遇到的问题调整传输策略； IMCP报文封装在IP包中，因为它需要探测源地址和目标地址之间的网络状况，IMCP报文的类型有很多，常用的为主动请求——8，主动请求应答——0。报文示意图 查询报文类型，如ping： 它是一种主动请求，并且获得主动应答的ICMP协议， 对于ping的请求进行网络抓包，叫做ICMP ECHO REQUEST； 主动请求的回复叫做ICMP ECHO REPLY。 相比原生ICMP，ping增加了两个字段：标识符和序号，标识符用于区分不同的任务，序号用于统计网络状况； ping中还可以添加时间，用于计算路程长短； 差错报文类型，如Traceroute： 终点不可达——3，具体可能为网络不可达、主机不可达、协议不可达、端口不可达、需设置分片； 源站抑制——4，即让源站降低发送速度； 时间超时——11，超过网络包发送的时间还未送到； 路由重定向——5，让下次发给另一个路由； 网关一、 MAC头和IP头细节 示意图 MAC头中的协议类型用来说明是IP协议； IP头中的版本号，目前主流的是IPv4； 8位的协议标识表明是TCP还是UDP； 二、 路由器 任何一个机器方位一个IP时，都会判断是否在同一个网段： 倘若是，则使用ARP获取MAC地址， 不是，就需要使用网关，网关和源IP同一个网段，默认是网段的第一个IP或第二个，通过ARP获取网关MAC地址，放入MAC头中发送到网关； 网关是一个三层设备，但称其为路由器是不准确的，路由器是一台设备，它有五个网口或网卡，分别连着五个局域网，每个网口的IP地址和局域网IP属于同一个网段，每只手都是它握住的局域网的网关； 三、 静态路由 送入路由器网关的数据，应该由哪个网口发送出去？IP头和MAC头如何改变？上述问题的解决有两种方案：静态路由和动态路由。 静态路由：原理是在路由器上配置一条条规则，指定访问那些网站从哪些口出去； MAC地址是在局域网内有效，因此只要通过网关，必定会改变。 IP地址是否会改变取决于网关的类型： 转发网关：不改变IP地址。这种情况下局域网之间进行过协调，通过协调网段使得IP不会冲突； NAT网关：改变IP地址。这种情况下局域网各自指定自己的网段，导致IP段冲突，这就设计IP头的更改： 首先本地IP是192.168.1.101/24，目的IP也是192.168.1.101/24，此时就需要在中间局域网中使用国际身份证，假设目标IP对应的国际身份证是192.168.56.2。于是源主机访问目标主机就是用目标主机的国际身份证192.168.56.2。 路由器A收到源主机的网络包，根据路由规则将网络包发送到目的路由，同时更改源主机的IP为其国际IP； 路由器B收到路由器A的网络包，根据路由规则得知访问192.168.56.2对应访问192.168.1.101，于是更改IP和MAC将网络包发送到目标IP NAT映射并不能缓解IP紧张的问题，因此出现了NAPT； 四、 路由协议 路由器会根据路由表正确的转发流量，一个路由表包含多条路由规则，每条规则至少包含三条信息： 目的网络； 出口设备； 下一跳网关； 举例如下： # 这种配置的核心思想是根据IP地址配置路由 ip route add 10.176.48.0/20 via 10.173.32.1 dev eth0 # 配置多个路由表 根据IP、入口设备、TOS选择相应路由表 ip rule add from 192.168.1.0/24 table 10 静态路由维护难度随网络的复杂度上升，因而需要引入动态路由算法； 动态路由可以根据路由协议算法生成动态路由表，随网络运行状况而变化，那么如何寻找最短路径呢？ 距离矢量路由算法：它是基于Bellman-Ford算法的，基本思想如下： 每个路由器保存一个路由表； 路由表中的每一行对应网络中的一个路由器； 每一行的信息由两部分构成：(1)去目标路由器从哪出去(2)到目标路由器的距离； 上述信息表明每个路由器都知道全局信息，每过几秒，路由器就将自己的路由表告知邻居，同时也收集邻居的路由信息，从而实现路由表的更新； 这种算法的缺点如下： 好消息传得块，坏消息传得慢； 每次发送都要发送全局路由表，所以它适用于小型网络(小于15跳) 链路状态路由算法，它是基于Dijkstra算法的，算法的基本思路如下： 新路由器启动，首先发现邻居，向邻居发送请求，邻居都恢复。 然后计算和邻居的距离，发送echo，要求马上返回，除以2就是距离。 广播自己和邻居之间的链路状态包，则网络上的每个路由都能在本地构建一个完整的图； 针对图舒勇Dijkstra算法，找到两点之间的最短路径； 动态路由协议： 基于链路状态路由算法的OSPF——开放式最短路径优先，广泛应用于数据中心，也称内部网关协议IGP。 在一个组织内部，最短路径往往是最优的； 当存在多个最短路径时，它们被称为等价路由，可以在这些等价路由上使用负载均衡； 基于距离矢量路由算法的外网路由协议BGP，国家之间的路由协议，不光考虑远近问题，还要考虑政策。 在网络世界中一个国家就是一个自治系统AS，自治系统分为几种： Stub AS，这种AS不会传输其他AS的包； multihomed AS，可以连接到其他AS，但大都拒绝帮其他AS传输包； Transit AS，由多个连接到其他AS并可以帮助其他AS传输包。 每个自治路由器都有边界路由器，通过该路由器和外界建立联系； BGP分为两类： eBGP，边界路由器之间只用eBGP广播路由； iBGP，使用iBGP寻找内部达到外部路由的最好的边界路由； 传输层一、 TCP和UDP 我们都知道TCP使面向连接的、可靠的、基于字节流的，而UDP是无连接的，二者的差异如下： TCP提供可靠交互，TCP传输的数据无差错、不丢失、不重复且有序到达，而UDP继承了IP包的特性，不保证不丢失和有序性； TCP是面向字节流的，发送的是没头没尾的字节流，而UDP继承了IP包的特性，基于数据报，逐个发送； TCP是可以有拥塞控制的，会根据网络状态调整发送速度，而UDP没有这种特性； TCP是一个有状态的服务，精确记录发送和接受状态，保证发送正确无误，而UDP则是无状态的； MAC层定义本地局域网的传输行为，IP层定义整个网络端到端的行为，网络传输以包为单位，二层叫帧，三层叫包，四层叫段。将其统称为包，包单独传输，自行选路，再不同的设备间封装解封，不保证到达，UDP完全继承这种特性； 二、UDP 根据IP层的8位协议可以区分是TCP还是UDP，内核检查传输层端口并将数据交给监听对应端口的应用程序处理，UDP示意图。 UDP的三大特点： 沟通简单：不需要维护大量数据结构、处理逻辑、包头字段； 轻信他人：不建立连接，任何人都可以向其发送数据，反之亦可，甚至可以同时给多个人传输数据； 不会变通：无法根据网络状态调整发送行为； UDP的使用场景： 需求资源少，网络状况较佳的内网或对于丢包不敏感的应用；，比如前文的DHCP和TFTP协议都是基于UDP的； 不需要一对一沟通建立连接，而实可以广播的应用，广播协议DHCP，使用D类地址的机器可以将包组播给一组机器，监听使用组播地址机器的机器，需要向路由器发送IGMP包，使得路由器收到组播地址发来的包时，就直接转送给相应的机器，实现跨路由组播； 需要处理速度块，低时延、能容忍丢包，无视网络状态随时发送的场景，比如流媒体协议； UDP的相关协议： 移动互联网往往会出现大量重连操作，然而基于TCP的三次握手建立连接会降低速度，因此快速UDP互联网连接QUIC应运而生，这是一种基于UDP的改进通信协议，运行在应用层上； 流媒体协议RTMC，TCP要求按顺序确认每个包的到达顺序，不符合直播实时性特点，另外视频对关键帧的要求较高，其他帧即使偶尔丢掉影响也可以忽略。而且TCP根据网络状态调整发送速度的特性也严重影响直播观感。所以就需要实现基于UDP的视频传输协议； 实时游戏，顾名思义，这类游戏对实时性要求极高，这就需要建立长连接保证实时性，然而服务器可以维护的TCP连接是有限的，无法应对大量玩家。这就需要引入无连接的UDP，以应对海量客户连接策略，另外对于丢包，实时游戏也需要额外处理，采用自定义UDP协议，自定义重传，能把丢包延迟降到最低； IOT物联网，物联网终端资源少，维护TCP代价太大，TCP的实时性也不能满足物联网的需求，因而谷歌提出了基于UDP的物联网通信协议Thread； 移动通信：4G网络中移动流量上网面对的协议GTP-U就是基于UDP的 三、TCP TCP头示意图: 包中的序号可以解决乱序问题； 确认序号保证发出去的包应该有送达确认； 状态位：SYN——发起连接、ACK——恢复、RST——重新连接、FIN——结束连接； 窗口大小，通信双方约定发送速度，进行流量控制； TCP的三次握手： 为什么是三次握手：为了确定双方具有收发能力。首先A发送YNC请求，B收到确定A具有发送能力，B发送ACK应答信号，A收到确定B具有收发能力，A发送应答的应答，B收到确认A具有接收能力，由此双方建立连接； 三次握手期间，建立连接同时确定TCP包的序号问题，A告诉B自己发起包的起始序号，B也告诉A自己发起包的起始序号；另外序号的起始并非1，由一个32位计数器控制，每四号秒加一，一个周期将近四个小时，从而避免重复问题。 TCP的四次挥手： 首先A发送断开连接FIN请求，进入FIN_WAIT_1状态，等待B的应答信号。若未收到，则重新发送。倘若A直接断开，则B的应答信号得不到回复，导致Bug。若B直接断开，A同样因收不到应答出现Bug； 其次B回复A的FIN请求，说知道了，进入CLOUSED_WAIT状态，继续处理未完成的任务，A收到B的ACK信号，进入FIN_WAIT_2状态。若此时B直接断开，A将永远处于这个状态(部分系统可以设置超时时间)。 B发送FIN请求，进入LAST_ACK状态； A收到B的FIN信号，向B发送ACK信号，进入TIME_WAIT状态，防止网络故障时，B因无法收到应答信号而重发FIN信号。等待时间要大于两个最大报文生存时间(MSL)，如果超过此时间，B依然没收到ACK，则A收到B的FIN时会发送RST信号，此时B就知道A已断开。 TCP状态机 TCP事项可靠连接使用的是累计应答机制。 发送端会维护一个队列，内部包括发送并确认的包、发送未确认的包、等待发送的包、暂时不发送的包；接收端会告知发送端一个Advertised window，窗口大小等于第二三部分的大小。于是发送端就会维护这样的数据结构： 接收端也会维护一个队列，内容包括接收已确认、等待接收未确认、不能接收吗，数据结构如下 假设4的应答收到了，但5的ACK丢了，6、7的数据包丢了。这时就需要启动确认与重发机制： 超时重试，即发送了但未应答就需要根据计时器重新尝试，计时时间需大于往返时间RTT，但不宜过长TCP采用加权法估计RTT，因此RTT是不断变化的，所以又叫做自适应重传算法。 假设一段时间后5，6的ACK都发送了，此时7的ACK丢了，此时TCP的策略是超时时间加倍。每遇到一次超时重传，都会加倍超时时间，两次超时则说明网络环境差，不宜频繁发送； 快速重传机制，当接收方收到序号大于期望序号的报文时，就会发送冗余ACK，发送端收到三个冗余ACK就会在定时器过期之前重发报文段； SACK，这也是一种快速重传方式，它在TCP头中加入一个SACK，将缓存地图发送给发送方，根据地图发送方就知道哪个包丢失； TCP的流量控制机制： 假设接收端一致不读取缓存中的数据，当收到一个包的ACK时，窗口未平移，仅左边界右移一个单位，此时窗口就会不断缩小，直到变为0，停止发送；此时发送方就会发送数据窗口探测包，看是否有机会调整窗口大小 TCP的拥塞控制问题： TCP的策略就是在不堵塞不丢包的情况下，尽量发挥宽带，同时避免超时和重传； 为了探测网络的宽带，TCP采用慢启动的方式，开始只发送一个，收到应答后每次发送两个，收到两个的应答后，每次发送四个···，如此循环指数增长，当值大于ssthresh时每","categories":[{"name":"Computer network","slug":"Computer-network","permalink":"http://sioce.me/categories/Computer-network/"}],"tags":[{"name":"Computer network","slug":"Computer-network","permalink":"http://sioce.me/tags/Computer-network/"}]},{"title":"JavaScript leaning","slug":"JavaScript-leaning","date":"2020-07-28T14:06:50.000Z","updated":"2020-07-28T14:10:16.873Z","comments":true,"path":"2020/07/28/JavaScript-leaning/","link":"","permalink":"http://sioce.me/2020/07/28/JavaScript-leaning/","excerpt":"","text":"JavaScript基础基本数据类型 共六种：String/Number/Boolean/null/undefine/object； 数据类型之间的相互转换； JS计算精度不高； JS的基本运算；","categories":[{"name":"JS","slug":"JS","permalink":"http://sioce.me/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://sioce.me/tags/JS/"}]}],"categories":[{"name":"OS","slug":"OS","permalink":"http://sioce.me/categories/OS/"},{"name":"Computer network","slug":"Computer-network","permalink":"http://sioce.me/categories/Computer-network/"},{"name":"JS","slug":"JS","permalink":"http://sioce.me/categories/JS/"}],"tags":[{"name":"OS","slug":"OS","permalink":"http://sioce.me/tags/OS/"},{"name":"Computer network","slug":"Computer-network","permalink":"http://sioce.me/tags/Computer-network/"},{"name":"JS","slug":"JS","permalink":"http://sioce.me/tags/JS/"}]}