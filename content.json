{"meta":{"title":"Fujie's Blog","subtitle":"学习&生活","description":"","author":"Fujie","url":"http://sioce.me","root":"/"},"pages":[{"title":"archives","date":"2020-07-28T09:32:00.000Z","updated":"2020-07-28T09:32:00.735Z","comments":true,"path":"archives/index.html","permalink":"http://sioce.me/archives/index.html","excerpt":"","text":""},{"title":"about","date":"2020-07-28T07:33:12.000Z","updated":"2020-07-28T14:10:24.169Z","comments":true,"path":"about/index.html","permalink":"http://sioce.me/about/index.html","excerpt":"","text":"About不断学习，保持热爱！ Contact Me🕸 github: F-jie📧 email: 163"},{"title":"categories","date":"2020-07-28T09:31:48.000Z","updated":"2020-07-28T09:31:48.748Z","comments":true,"path":"categories/index.html","permalink":"http://sioce.me/categories/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-07-28T09:33:43.000Z","updated":"2020-07-28T09:33:43.791Z","comments":true,"path":"categories/index-1.html","permalink":"http://sioce.me/categories/index-1.html","excerpt":"","text":""},{"title":"tags","date":"2020-07-28T07:33:23.000Z","updated":"2020-07-28T07:33:23.954Z","comments":true,"path":"tags/index.html","permalink":"http://sioce.me/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"OS virtualization","slug":"OS-virtualization","date":"2020-07-29T13:44:46.000Z","updated":"2020-07-29T14:48:04.651Z","comments":true,"path":"2020/07/29/OS-virtualization/","link":"","permalink":"http://sioce.me/2020/07/29/OS-virtualization/","excerpt":"","text":"第一章 操作系统简介 冯·诺伊曼计算机模型：取指令、解码、运行。 操作系统使程序的运行更加容易，且高效正确。为了实现这一目的，操作系统需要使用虚拟化技术——即将物理资源转化为更通用、更强大且易于使用的虚拟形式。用户使用操作系统提供的API访问硬件资源。 虚拟化CPU，这使得系统在只有一个处理器的前提下同时运行多个程序，为了控制程序的开始和结束，需要使用相关的接口，向操作系统传递需求。操作系统的策略将会控制特定时间运行哪个程序——这由操作系统的基本机制决定。 虚拟化内存，现代机器提供的物理内存就是一个字节数组，读数据需要指定地址，写数据需要指定地址和数据。操作系统虚拟化内存时，每个进程访问私有的虚拟地址空间，OS以某种方式将该地址空间映射到机器的物理内存上。 并发问题，这一问题首先出现在操作系统本身上，此外在现代多线程程序中也存在这样的问题； 持久性，内存中的数据需要依靠硬件和软件辅助存储，硬件通常指磁盘，软件则为文件系统，软件负责将用户创建的内容存储到硬盘中。 操作系统会提供CPU和内存的抽象，但不会为每个应用程序创建虚拟磁盘； 总结：操作系统取得CPU、内存以及磁盘等物理资源，并对之进行虚拟化；处理并发可能引起的问题；对文件进行持久化存储。这些过程最重要的是抽象，抽象是编写大型程序必不可少的部分。 操作系统设计的目标： 高性能，操作系统的开销以额外的时间和空间的形式出现，但必须容忍不完美； 提供程序间以及OS和程序间的保护，为了实现这一目标，隔离是一种基本原理； 可靠性：事实上，这方面有许多正在进行的研究； 其他目标主要有：能源效率、安全性和移动性等。 第四章 操作系统的基本抽象——进程 进程的非正式定义——运行中的程序 为了实现CPU的虚拟化，需要使用分时共享CPU技术，虽然不可避免的引入潜在的性能损失但很值得。实现优秀的CPU虚拟化，需要搭配使用低级机制和高级智能： 低级机制——机制(mechanism)，如上下文切换； 高级智能——策略(policy)，这指的是操作系内的决定算法； 进程的机器状态对理解进程的构成十分重要： 机器状态一——地址空间，即内存，内存中保存着程序的指令、读取的数据等； 机器状态二——寄存器，许多指令需要对寄存器进程读写； 机器状态三——程序计数器(指令指针，IP)； 进程API 创建(create) 销毁(destroy) 等待(wait) 其他控制(miscellaneous control) 状态(status) 进程的创建，程序-&gt; -&gt;进程： 操作系统加载代码和静态数据至内存中属于进程的地址空间；(现代操作系统惰性执行该过程，这涉及到分页和交换机制——内存虚拟化)； 为程序的运行时栈分配内存，C语言拥栈保存局部变量、函数参数和返回地址； 为程序的堆分配内存，C语言中堆用于存储显示动态分配数据，数据结构也需要堆，堆的大小会变化； 为输入输出任务创建三个文件描述符，用于标准的输入输出以及错误。 进程的状态： 运行：正在处理器上执行； 就绪：等待被调用； 阻塞：等待某种操作完成。 数据结构，操作系统需要使用某些关键的数据结构跟踪相关的信息： 为所有就绪的进程保留进程列表； 跟踪正在运行进程的附加信息； 跟踪被阻塞进程； I/O完成时，正确地唤醒进程； 第五章 进程API UNIX系统使用一对系统调用fork()/exec()创建进程，另外进程还可以使用系统调用wait()等待其创建子进程执行完成； fork()系统调用：使用该系统调用创建子进程，子进程fork()调用的返回值为0，父进程fork()调用返回值为子进程PID； wait()系统调用，该系统调用在子进程运行结束后才返回； exec()系统调用，它还有其他几种变体：execl、execle、execlp、execv、execvp。假设使用execvp运行字符计数程序，exec会从可执行程序中加载代码和静态数据并覆写自己的代码段，堆栈及相应的地址空间也会重新初始化。 之所以设计fork和exec，是为了程序能够运行fork之后，exec之前构建的代码，比如shell，它首先显示命令提示符，等待用户输入，用户输入指令后，shell调用fork创建新的进程，再调用exec的某个变体执行命令中的可执行程序，最后调用wait等待该子进程结束，子进程结束后，shell再输出命令提示符； 重定向的实现原理：再创建子进程之后，关闭标准输入输出，同时打开重定向的文件，最后调用exec。 UNIX系统的管道，pipe()系统调用可以将一个进程的输出无缝连接到另一个进程的输入上，如grep -o foo file | wc -l","categories":[{"name":"OS","slug":"OS","permalink":"http://sioce.me/categories/OS/"}],"tags":[{"name":"OS","slug":"OS","permalink":"http://sioce.me/tags/OS/"}]},{"title":"computer network","slug":"computer-network","date":"2020-07-28T14:12:54.000Z","updated":"2020-07-29T13:13:41.309Z","comments":true,"path":"2020/07/28/computer-network/","link":"","permalink":"http://sioce.me/2020/07/28/computer-network/","excerpt":"","text":"分层一 总分为七层，这里忽略应用层后的表示层和会话层 名称 协议 应用层 DHCP、HTTP、HTTPS、TRTMP、P2P、DNS、GTP、RPC 传输层 UDP、TCP 网络层 IMCP、IP、OSPF、BGP、IPSec、GRE 链路层 ARP、VLAN、STP 物理层 网络跳线 二 网络层的IP地址和链路层的MAC地址虽均能唯一确定用户 但IP可能是动态分布的，用户可能随时下线，此时就需要使用MAC进行区分； MAC是早期局域网通信的产物； 之所以提出IP协议是因为MAC的查找效率低下，另外MAC地址是通过ARP协议获取的，不易处理广播风暴问题； 三 关于网络分层的四个问题 TCP三次握手，MAC和IP对应什么操作？ 已知原始地址和目标地址，其间需通过两个中转站B、C，包在中转站时是如何知道最终目的地的呢？ 我们知道二层设备和三层设备，那么二层设备处理的包的内容是否包含第七层的的内容呢？ SSH登录公有云主机，都经历那些过程呢？ 解答：复杂的程序都是要分层的，网络协议同样如此，网络中的包可以由下层没上层，反之则不成立； 经过网口的网络包会被相应的程序处理(混杂模式)： 首先摘掉第二层的头进行比对，若MAC地址一致，则交给网络层处理； 其次摘掉第三层的头比对IP，不一致则进行转发，否则交给传输层处理； 再其次拿掉第四层的头，交给TCP或者UDP处理，若是一个正常的数据包，则交给监听相应端口的应用程序，若是发起或应答，则需要发送回复包。 二层设备仅处理链路层的MAC地址，三层设备另外需要处理网络层的IP地址； IP地址一 查询IP地址的指令：ifconfig、ip addr、ipconfig二 IP地址的分类 类别 头标识 网络号(bit) 主机号(bit) A 0 7 24 B 10 14 16 C 110 21 8 类别 头标识 其他 D 1110 多播组号(28) E 11110 留待后用(27) 类别 IP地址范围 最大主机数 私有IP地址范围 A 0.0.0.0-127.255.255.255 16777214 10.0.0.0-10.255.255.255 B 128.0.0.0-191.255.255.255 65534 172.16.0.0-172.31.255.255 C 162.0.0.0-233.255.255.255 254 192.168.0.0-192.168.255.255 由上表可见，A、B、C三类IP的主机数分配严重不均，因而出现了无类型域间选路(CIDR): CIDR将IP地址分为两部分，前面是网络号，后面是主机号，如10.100.122.2/24，24表示网络号长度； 和CIDR共存的是广播地址和子网掩码，如10.100.122.2/24对应的广播地址为10.100.122.255，子网掩码是255.255.255.0，向广播地址发送数据，则10.100.122.:中的所有机器都能收到；将IP和子网掩码进行与操作，即可得网络号。 工作中几乎不涉及IP分类，仅使用CIDR，但需要区分公有IP和私有IP。每个网段中的第一个地址往往是网络的出口地址，最后一个地址则是广播地址； 组播地址，使用这类地址，属于某个组的机器都能收到； MAC地址，它虽然是唯一的，但不具备大范围定位功能。它能避免组网过程中的冲突问题。 网络的状态标识(net_device flags)： UP：表示网卡启动； BROADCAST：表示网卡有广播地址，可发送广播包； MULTICAST：表示网卡可发送多播包； LOWER_UP：表示L1启动，即网线插入； MTU1500：表示最大传输单元，它属于第二层链路层概念，当MAC头加正文大于1500自己时，需要启动分片传输； queueing discipline：表示排队规则，内核通过网络接口发送数据，需要为该接口配置排队规则将数据包加入队列 pfifo：先入先出； pfifo-fast：它的队列包含三个波段，每个波段先入先出，根据服务类型TOC将数据包放入不同的波段； IP地址的分配一 手动配置# 使用ifconfig sudo ifconfig eth1 10.0.0.1/24 sudo ifconfig eth1 up #使用iproute2 sudo ip addr add 10.0.0.1/24 dev eth1 sudo ip link set up eth1 二 动态主机配置协议(DHCP)，主要机制 新机器使用IP0.0.0.0向目标IP255.255.255.255发送广播，内部使用UDP封装BOOTP； DHCP SERVER，收到广播，辨识MAC，向新机器分配IP，此过程成为DHCP Offer，DHCP Server同样使用0.0.0.0作为本机IP，向广播IP255.255.255.255发送包括IP在内的子网掩码、网关、IP租用期等数据。 新机器收到广播，向广播IP发送DHCP Request数据包，包括自身MAC、接受的IP、提供IP的DHCP服务器地址等，此时新机器的IP仍为0.0.0.0。 DHCP Server收到客户端DHCP Request，使用本机IP向客户机发送DHCP ACK消息，接受客户机选择。 在租用期过去一半时，客户机会向对应的DHCP Server发送DHCP Request消息，并根据服务器返回的ACK消息更新租用期限和TCP/IP参数。 三 预启动执行环境(PXE)，使用PXE管理员可以自动给数据中心的服务器安装操作系统 操作系统的启动： 启动BIOS，读取硬盘MBR启动扇区，启动GRUB； GRUB加载内核、作为根文件系统initramfs文件； 内核启动，初始化操作系统； PXE在BIOS启动之后发挥作用，主要流程如下： PXE客户端放在BIOS中，通过BIOS将PXE加载到内存中； PXE客户端发起DHCP请求，HDHCP Server给PXE客户端分配IP，并告知其PXE服务器地址、启动文件位置； PXE客户端使用TFTP协议向TFTP服务器请求下载启动文件，所以PXE服务器上还需要配置TFTP服务器； PXE客户端根据收到的启动文件向TFTP服务器请求计算机配置信息文件，告知客户端内核、initramfs位置； PXE客户端请求内核文件和initramfs文件； PXE客户端启动操作系统内核。 MAC——媒体访问控制一 网络中的第一层当局域网中只有一台计算机时，只需要使用交叉网线并配置IP、子网掩码、默认网关即可。当设备数量增加时，就需要使用集线器Hub，它工作在物理层，将收到的每一个字节复制到其他端口上。 二 网络中的第二层——数据链路层 Hub采用广播的模式发送数据，面临一下问题： 谁发的包？谁接受包？ 多台设备同时发包的先后顺序？ 发送错误，如何处理？ 数据链路层负责解决上述问题： 多路访问解决问题二，主要算法有： 信道划分——分多个信道，互不干扰； 轮流协议——类似单双号限行； 随机接入协议——需要则发送，拥堵则错过高峰再进行发送，以太网即采用这种方式； 链路层地址负责解决问题一，该地址也叫做MAC地址，第二层网络包格式如下： 网络包中的类型大部分为IP数据包，其内部包含TCP、UDP、HTTP等的封装 × 目标MAC 源MAC 类型 数据 CRC 位数(bytes) 6 6 2 46~1500 4 类型 内容 0800 IP数据报 0806 ARP请求、应答 上表网络包中的循环冗余检测CRC用于解决问题三，使用XOR异或算法计算整个包再在发送的过程中是否出错。 如何获取目标机器的MAC地址？ARP协议： 当已知目标IP时，本机会首先查询本地ARP缓存，求MAC地址，找不到则发送ARP广播； 目标IP收到广播，在通过ARP广播发送自身MAC地址； ARP报文如ARP报文所示； 二层设备——交换机 Hub采用广播的方式将每个网络包复制到每个网口，浪费资源且易产生冲突，如果转发设备能够记忆每个网口对应主机的MAC地址，这种情况就能得到缓解，这就是交换机； 通过不断学习，交换机会维护一个转发表，注意转发表也是有过期时间的； 三 多台交换机——拓扑结构 拓扑结构中的环路问题示意图; STP协议——计算机网络中的生成树算法 基本概念有： 根交换机(Root Bridge)：某棵树的老大，类似掌门； 指定交换机(Designated Bridge)：拜此交换机做大哥的的交换机，也是此交换机大哥的小弟； 网桥协议数据单元(BPDU)：比较实力的协议； 优先级向量(Priority Vector)：实力； 工作过程： 起初所有的交换机都以自己为掌门，但网络管理员会根据交换机的性能给交换机分配高优先级； 所有的交换机互相发送BPDU，进行比较，形成小的从属关系； 掌门遇掌门，根据优先级决定门派合并； 掌门与小弟，根据距离决定汇报路径； 同门遇同门，比较与小弟距离决定从属关系； 掌门与外派小弟，比较掌门优先级； 非同门小弟相遇，比较掌门优先级； 广播问题和安全问题： 为了保障广播的安全和流畅问题，有两种解决方案： 物理隔离，每个部门设置单独交换机、单独子网，部门间使用路由器交流； 虚拟隔离，即VLAN虚拟局域网，在原来二层头的基础上增加一个TAG，一共12位，交换机取下二层头，检测VLAN，根据VLAN的值决定是否进行转发。这样这需要配置交换机每个网口的VLAN值即可实现虚拟隔离；此时交换机之间的连接口叫做Trunck口，它可以转发属于任何VLAN的口； 网络层一 IMCP协议 ping指令就是基于IMCP协议工作的。IMCP全称互联网控制报文协议。互联网的状况复杂，需要根据遇到的问题调整传输策略； IMCP报文封装在IP包中，因为它需要探测源地址和目标地址之间的网络状况，IMCP报文的类型有很多，常用的为主动请求——8，主动请求应答——0。报文示意图 查询报文类型，如ping： 它是一种主动请求，并且获得主动应答的ICMP协议， 对于ping的请求进行网络抓包，叫做ICMP ECHO REQUEST； 主动请求的回复叫做ICMP ECHO REPLY。 相比原生ICMP，ping增加了两个字段：标识符和序号，标识符用于区分不同的任务，序号用于统计网络状况； ping中还可以添加时间，用于计算路程长短； 差错报文类型，如Traceroute： 终点不可达——3，具体可能为网络不可达、主机不可达、协议不可达、端口不可达、需设置分片； 源站抑制——4，即让源站降低发送速度； 时间超时——11，超过网络包发送的时间还未送到； 路由重定向——5，让下次发给另一个路由； 网关MAC头和IP头细节 示意图 MAC头中的协议类型用来说明是IP协议； IP头中的版本号，目前主流的是IPv4； 8位的协议标识表明是TCP还是UDP； 路由器 任何一个机器方位一个IP时，都会判断是否在同一个网段： 倘若是，则使用ARP获取MAC地址， 不是，就需要使用网关，网关和源IP同一个网段，默认是网段的第一个IP或第二个，通过ARP获取网关MAC地址，放入MAC头中发送到网关； 网关是一个三层设备，但称其为路由器是不准确的，路由器是一台设备，它有五个网口或网卡，分别连着五个局域网，每个网口的IP地址和局域网IP属于同一个网段，每只手都是它握住的局域网的网关； 静态路由 送入路由器网关的数据，应该由哪个网口发送出去？IP头和MAC头如何改变？上述问题的解决有两种方案：静态路由和动态路由。 静态路由：原理是在路由器上配置一条条规则，指定访问那些网站从哪些口出去； MAC地址是在局域网内有效，因此只要通过网关，必定会改变。 IP地址是否会改变取决于网关的类型： 转发网关：不改变IP地址。这种情况下局域网之间进行过协调，通过协调网段使得IP不会冲突； NAT网关：改变IP地址。这种情况下局域网各自指定自己的网段，导致IP段冲突，这就设计IP头的更改： 首先本地IP是192.168.1.101/24，目的IP也是192.168.1.101/24，此时就需要在中间局域网中使用国际身份证，假设目标IP对应的国际身份证是192.168.56.2。于是源主机访问目标主机就是用目标主机的国际身份证192.168.56.2。 路由器A收到源主机的网络包，根据路由规则将网络包发送到目的路由，同时更改源主机的IP为其国际IP； 路由器B收到路由器A的网络包，根据路由规则得知访问192.168.56.2对应访问192.168.1.101，于是更改IP和MAC将网络包发送到目标IP NAT映射并不能缓解IP紧张的问题，因此出现了NAPT； 路由协议 路由器会根据路由表正确的转发流量，一个路由表包含多条路由规则，每条规则至少包含三条信息： 目的网络； 出口设备； 下一跳网关； 举例如下： # 这种配置的核心思想是根据IP地址配置路由 ip route add 10.176.48.0/20 via 10.173.32.1 dev eth0 # 配置多个路由表 根据IP、入口设备、TOS选择相应路由表 ip rule add from 192.168.1.0/24 table 10 静态路由维护难度随网络的复杂度上升，因而需要引入动态路由算法； 动态路由可以根据路由协议算法生成动态路由表，随网络运行状况而变化，那么如何寻找最短路径呢？ 距离矢量路由算法：它是基于Bellman-Ford算法的，基本思想如下： 每个路由器保存一个路由表； 路由表中的每一行对应网络中的一个路由器； 每一行的信息由两部分构成：(1)去目标路由器从哪出去(2)到目标路由器的距离； 上述信息表明每个路由器都知道全局信息，每过几秒，路由器就将自己的路由表告知邻居，同时也收集邻居的路由信息，从而实现路由表的更新； 这种算法的缺点如下： 好消息传得块，坏消息传得慢； 每次发送都要发送全局路由表，所以它适用于小型网络(小于15跳) 链路状态路由算法，它是基于Dijkstra算法的，算法的基本思路如下： 新路由器启动，首先发现邻居，向邻居发送请求，邻居都恢复。 然后计算和邻居的距离，发送echo，要求马上返回，除以2就是距离。 广播自己和邻居之间的链路状态包，则网络上的每个路由都能在本地构建一个完整的图； 针对图舒勇Dijkstra算法，找到两点之间的最短路径； 动态路由协议： 基于链路状态路由算法的OSPF——开放式最短路径优先，广泛应用于数据中心，也称内部网关协议IGP。 在一个组织内部，最短路径往往是最优的； 当存在多个最短路径时，它们被称为等价路由，可以在这些等价路由上使用负载均衡； 基于距离矢量路由算法的外网路由协议BGP，国家之间的路由协议，不光考虑远近问题，还要考虑政策。 在网络世界中一个国家就是一个自治系统AS，自治系统分为几种： Stub AS，这种AS不会传输其他AS的包； multihomed AS，可以连接到其他AS，但大都拒绝帮其他AS传输包； Transit AS，由多个连接到其他AS并可以帮助其他AS传输包。 每个自治路由器都有边界路由器，通过该路由器和外界建立联系； BGP分为两类： eBGP，边界路由器之间只用eBGP广播路由； iBGP，使用iBGP寻找内部达到外部路由的最好的边界路由；","categories":[{"name":"Computer network","slug":"Computer-network","permalink":"http://sioce.me/categories/Computer-network/"}],"tags":[{"name":"Computer network","slug":"Computer-network","permalink":"http://sioce.me/tags/Computer-network/"}]},{"title":"JavaScript leaning","slug":"JavaScript-leaning","date":"2020-07-28T14:06:50.000Z","updated":"2020-07-28T14:10:16.873Z","comments":true,"path":"2020/07/28/JavaScript-leaning/","link":"","permalink":"http://sioce.me/2020/07/28/JavaScript-leaning/","excerpt":"","text":"JavaScript基础基本数据类型 共六种：String/Number/Boolean/null/undefine/object； 数据类型之间的相互转换； JS计算精度不高； JS的基本运算；","categories":[{"name":"JS","slug":"JS","permalink":"http://sioce.me/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://sioce.me/tags/JS/"}]}],"categories":[{"name":"OS","slug":"OS","permalink":"http://sioce.me/categories/OS/"},{"name":"Computer network","slug":"Computer-network","permalink":"http://sioce.me/categories/Computer-network/"},{"name":"JS","slug":"JS","permalink":"http://sioce.me/categories/JS/"}],"tags":[{"name":"OS","slug":"OS","permalink":"http://sioce.me/tags/OS/"},{"name":"Computer network","slug":"Computer-network","permalink":"http://sioce.me/tags/Computer-network/"},{"name":"JS","slug":"JS","permalink":"http://sioce.me/tags/JS/"}]}